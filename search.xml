<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>FreeRTOS schdule</title>
    <url>/2025/05/04/FreeRTOS-schdule/</url>
    <content><![CDATA[<blockquote>
<p>FreeRTOS schdule及系统节拍相关</p>
</blockquote>
<span id="more"></span>

<h2 id="1-BG"><a href="#1-BG" class="headerlink" title="1 BG"></a>1 BG</h2><p>FreeRTOS默认使用systick作为系统节拍，一般设置为1ms一次，改系统节拍用于task调度等。在自己做的项目中，采用默认的systick作为FreeRTOS的系统节拍，且<strong>systick未配置为External Clock</strong>，仅能使用Processor Clock。</p>
<p>但是在多master的角度，cpu的main_clk和voltage调整是由一个特定的scp来做的，就会导致时钟切换和当前cpu收到notify是异步的。在两个节点之间，FreeRTOS整个工作都多多少少存在一些异常。例如：</p>
<ol>
<li>timestamp问题<br> 我自己所做工作对时间戳有比较高的要求，但当前cpu并不像A核或者像vdsp等有RTC的访问权限，只能隔一段时间从APCPU发送mailbox msg用以sync时间戳，然后通过systick用以本地更新。但在切换当前cpu的mainclk且还未收到通知时，实际clk与systick配置的差异导致时间戳更新的飞快，然后等APCPU sync时间戳，会产生较大的时间戳回退。</li>
<li>delay问题<br> 虽然<code>vTaskDelay()</code>函数强调了并不能提供一个精准的延时，但在task的具体业务，或者某个driver中，还是经常能被用到。同样的，当在切换当前cpu的mainclk且还未收到通知时，delay会出现较大的误差，导致业务流程产生问题。</li>
</ol>
<h2 id="2-tick中断设置"><a href="#2-tick中断设置" class="headerlink" title="2 tick中断设置"></a>2 tick中断设置</h2><h3 id="2-1-中断源修改"><a href="#2-1-中断源修改" class="headerlink" title="2.1 中断源修改"></a>2.1 中断源修改</h3><p><code>freertos/portable/GCC/ARM_CM7/r0p1/port.c</code>中的函数<code>vPortSetupTimerInterrupt</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Setup the systick timer to generate the tick interrupts at the required</span></span><br><span class="line"><span class="comment"> * frequency.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__attribute__( ( weak ) ) <span class="type">void</span> <span class="title function_">vPortSetupTimerInterrupt</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Calculate the constants required to configure the tick interrupt. */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_TICKLESS_IDLE == 1 )</span></span><br><span class="line">        &#123;</span><br><span class="line">            ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );</span><br><span class="line">            xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;</span><br><span class="line">            ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configUSE_TICKLESS_IDLE */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Stop and clear the SysTick. */</span></span><br><span class="line">    portNVIC_SYSTICK_CTRL_REG = <span class="number">0UL</span>;</span><br><span class="line">    portNVIC_SYSTICK_CURRENT_VALUE_REG = <span class="number">0UL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Configure SysTick to interrupt at the requested rate. */</span></span><br><span class="line">    portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - <span class="number">1UL</span>;</span><br><span class="line">    portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数的调用pipeLine为<code>vTaskStartScheduler()</code> → <code>xPortStartScheduler()</code> → <code>vPortSetupTimerInterrupt()</code>，作用是配置systick中断，<code>portNVIC_SYSTICK_LOAD_REG</code>配置count计数，<code>portNVIC_SYSTICK_CTRL_REG</code>是systick中断control寄存器，可以配置使用mainclk或外部时钟。<br><code>configUSE_TICKLESS_IDLE</code>宏用以开启<code>TICKLESS_MODE</code>，后续即配置Systick中断的频率。</p>
<p>同时，该函数被标记为weak，<code>__attribute__( ( weak ) )</code> ，表明该函数是可以被强符号函数覆盖掉。如果在使用场景中，运行 FreeRTOS的cpu的频率并非固定不变（存在dvfs等），实现同步重新配置systick寄存器难以实现或者比较复杂，可以尝试使用一个外部固定时钟源来确保系统运行的稳定。</p>
<p>下面两张图是使用外部timer来实现的vPortSetupTimerInterrupt ，汇编中能够看到该函数已经被覆盖。<br><img src="/2025/05/04/FreeRTOS-schdule/external_timer_irq.png" alt="ext_timer_interrupt_c"><br><img src="/2025/05/04/FreeRTOS-schdule/ext_timer_irq_asm.png" alt="ext_timer_interrupt_asm"></p>
<h3 id="2-2-irq-handler修改"><a href="#2-2-irq-handler修改" class="headerlink" title="2.2 irq handler修改"></a>2.2 irq handler修改</h3><p>在Section 2.1重新设置了系统节拍的中断，需要同时修改当前中断的handler，使FreeRTOS能够正常调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">xPortSysTickHandler</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIMER_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	TIMER timer = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">	timer.TimerNIntStatus_REG.value = readw(TIMER_N_INT_STATUS_REG_ADDR);</span><br><span class="line">	timer.TimersIntStatus_REG.value = readw(TIMERS_INT_STATUS_REG_ADDR);</span><br><span class="line">	timer.TimersEOI_REG.value = readw(TIMERS_EOI_REG_ADDR); <span class="comment">// read clear above 2 reg bit</span></span><br><span class="line"></span><br><span class="line">	xPortSysTickHandler();</span><br><span class="line"></span><br><span class="line">	g_irq_cnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在hw_timer进行常规的清理中断之后，调用<code>xPortSysTickHandler()</code></p>
<h2 id="3-xPortSysTickHandler"><a href="#3-xPortSysTickHandler" class="headerlink" title="3 xPortSysTickHandler()"></a>3 <code>xPortSysTickHandler()</code></h2><p>source code:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">xPortSysTickHandler</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* The SysTick runs at the lowest interrupt priority, so when this interrupt</span></span><br><span class="line"><span class="comment">     * executes all interrupts must be unmasked.  There is therefore no need to</span></span><br><span class="line"><span class="comment">     * save and then restore the interrupt mask value as its value is already</span></span><br><span class="line"><span class="comment">     * known. */</span></span><br><span class="line">    portDISABLE_INTERRUPTS();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Increment the RTOS tick. */</span></span><br><span class="line">        <span class="keyword">if</span>( xTaskIncrementTick() != pdFALSE )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* A context switch is required.  Context switching is performed in</span></span><br><span class="line"><span class="comment">             * the PendSV interrupt.  Pend the PendSV interrupt. */</span></span><br><span class="line">            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    portENABLE_INTERRUPTS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是关闭中断，因为系统节拍中断的优先级通常设置的比较低，为了防止handler被打断。</p>
<p><code>xTaskIncrementTick()</code> 为系统节拍中断的<strong>核心函数</strong>，当其<code>ret==pdTRUE</code> 时，触发PendSV中断，进行task的上下文切换，该部分的详细流程<strong>待补充</strong>。</p>
<p>当<code>ret==pdFalse</code> 表示不需要进行切换，接下来分析<code>xTaskIncrementTick()</code></p>
<h3 id="3-1-xTaskIncrementTick"><a href="#3-1-xTaskIncrementTick" class="headerlink" title="3.1 xTaskIncrementTick()"></a>3.1 <code>xTaskIncrementTick()</code></h3><h3 id><a href="#" class="headerlink" title></a></h3><ol>
<li><p><code>xTickCount</code> </p>
<ul>
<li><p><code>uxSchedulerSuspended</code> </p>
<p>  首先是FreeRTOS中的静态变量<code>uxSchedulerSuspended</code> ，该变量在调用<code>vTaskSuspendAll()</code>时会自增1，表示调度器被挂起，调用<code>vTaskResumeAll()</code>函数时会自减1。该处仅讨论调度器未被挂起时的情况，即<code>uxSchedulerSuspended == ( UBaseType_t ) pdFALSE</code> 。</p>
</li>
<li><p><code>xTickCount</code><br>  该val定义如下：</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span>( configUSE_16_BIT_TICKS == 1 )</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">uint16_t</span> TickType_t;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> portMAX_DELAY ( TickType_t ) 0xffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">uint32_t</span> TickType_t;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> portMAX_DELAY ( TickType_t ) 0xffffffffUL</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> <span class="keyword">volatile</span> TickType_t xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;</span><br></pre></td></tr></table></figure></li>
</ul>
<p> 可以看到在32位平台上，该变量默认位32位，最大值为<code>0xffffffffUL</code> ，在1ms一次tick的情况下，大约在1193h后tick就会溢出，溢出判断为<code>xConstTickCount == ( TickType_t ) 0U</code> 具体的处理在之后补充。
 </p>
</li>
<li><p>delay task处理</p>
<p> 随后比较当前tick和<code>xNextTaskUnblockTime</code> ，FreeRTOS中维护了delay task list，即<code>pxDelayedTaskList</code> ，在task中调用延时函数（如<code>vTaskDelay()</code>）之后，会调用<code>prvAddCurrentTaskToDelayedList()</code> 将该task TCB中的list插入到delay task list（类似于Linux内核链表），<code>xNextTaskUnblockTime</code> 即为该list中，最早需要被唤醒的task。</p>
<p> 如果该list非空，去除已经超时task的TCB，再进行一次判断确定超时之后，将该task从<code>pxDelayedTaskList</code> 中移除，同时将该task状态置为ready，插入ready list <code>pxReadyTasksLists</code> ，如果该task的优先级&gt;当前正在运行的task优先级 且 开启抢占，将返回值置为<code>pdTRUE</code> 进行调度。</p>
</li>
<li><p>后续处理</p>
<p> 时间片切片的处理，相同优先级task共享时间片；</p>
<p> Tick的钩子函数等</p>
</li>
<li><p>source code</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskIncrementTick</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    TCB_t * pxTCB;</span><br><span class="line">    TickType_t xItemValue;</span><br><span class="line">    BaseType_t xSwitchRequired = pdFALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Called by the portable layer each time a tick interrupt occurs.</span></span><br><span class="line"><span class="comment">    * Increments the tick then checks to see if the new tick value will cause any</span></span><br><span class="line"><span class="comment">    * tasks to be unblocked. */</span></span><br><span class="line">    traceTASK_INCREMENT_TICK( xTickCount );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Minor optimisation.  The tick count cannot change in this</span></span><br><span class="line"><span class="comment">        * block. */</span></span><br><span class="line">        <span class="type">const</span> TickType_t xConstTickCount = xTickCount + ( TickType_t ) <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Increment the RTOS tick, switching the delayed and overflowed</span></span><br><span class="line"><span class="comment">        * delayed lists if it wraps to 0. */</span></span><br><span class="line">        xTickCount = xConstTickCount;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( xConstTickCount == ( TickType_t ) <span class="number">0U</span> ) <span class="comment">/*lint !e774 &#x27;if&#x27; does not always evaluate to false as it is looking for an overflow. */</span></span><br><span class="line">        &#123;</span><br><span class="line">            taskSWITCH_DELAYED_LISTS();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* See if this tick has made a timeout expire.  Tasks are stored in</span></span><br><span class="line"><span class="comment">        * the  queue in the order of their wake time - meaning once one task</span></span><br><span class="line"><span class="comment">        * has been found whose block time has not expired there is no need to</span></span><br><span class="line"><span class="comment">        * look any further down the list. */</span></span><br><span class="line">        <span class="keyword">if</span>( xConstTickCount &gt;= xNextTaskUnblockTime )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( ; ; )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* The delayed list is empty.  Set xNextTaskUnblockTime</span></span><br><span class="line"><span class="comment">                    * to the maximum possible value so it is extremely</span></span><br><span class="line"><span class="comment">                    * unlikely that the</span></span><br><span class="line"><span class="comment">                    * if( xTickCount &gt;= xNextTaskUnblockTime ) test will pass</span></span><br><span class="line"><span class="comment">                    * next time through. */</span></span><br><span class="line">                    xNextTaskUnblockTime = portMAX_DELAY; <span class="comment">/*lint !e961 MISRA exception as the casts are only redundant for some ports. */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* The delayed list is not empty, get the value of the</span></span><br><span class="line"><span class="comment">                    * item at the head of the delayed list.  This is the time</span></span><br><span class="line"><span class="comment">                    * at which the task at the head of the delayed list must</span></span><br><span class="line"><span class="comment">                    * be removed from the Blocked state. */</span></span><br><span class="line">                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); <span class="comment">/*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */</span></span><br><span class="line">                    xItemValue = listGET_LIST_ITEM_VALUE( &amp;( pxTCB-&gt;xStateListItem ) );</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>( xConstTickCount &lt; xItemValue )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* It is not time to unblock this item yet, but the</span></span><br><span class="line"><span class="comment">                        * item value is the time at which the task at the head</span></span><br><span class="line"><span class="comment">                        * of the blocked list must be removed from the Blocked</span></span><br><span class="line"><span class="comment">                        * state -  so record the item value in</span></span><br><span class="line"><span class="comment">                        * xNextTaskUnblockTime. */</span></span><br><span class="line">                        xNextTaskUnblockTime = xItemValue;</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">/*lint !e9011 Code structure here is deemed easier to understand with multiple breaks. */</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* It is time to remove the item from the Blocked state. */</span></span><br><span class="line">                    listREMOVE_ITEM( &amp;( pxTCB-&gt;xStateListItem ) );</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Is the task waiting on an event also?  If so remove</span></span><br><span class="line"><span class="comment">                    * it from the event list. */</span></span><br><span class="line">                    <span class="keyword">if</span>( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) != <span class="literal">NULL</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        listREMOVE_ITEM( &amp;( pxTCB-&gt;xEventListItem ) );</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Place the unblocked task into the appropriate ready</span></span><br><span class="line"><span class="comment">                    * list. */</span></span><br><span class="line">                    prvAddTaskToReadyList( pxTCB );</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* A task being unblocked cannot cause an immediate</span></span><br><span class="line"><span class="comment">                    * context switch if preemption is turned off. */</span></span><br><span class="line">                    <span class="meta">#<span class="keyword">if</span> ( configUSE_PREEMPTION == 1 )</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">/* Preemption is on, but a context switch should</span></span><br><span class="line"><span class="comment">                            * only be performed if the unblocked task has a</span></span><br><span class="line"><span class="comment">                            * priority that is equal to or higher than the</span></span><br><span class="line"><span class="comment">                            * currently executing task. */</span></span><br><span class="line">                            <span class="keyword">if</span>( pxTCB-&gt;uxPriority &gt;= pxCurrentTCB-&gt;uxPriority )</span><br><span class="line">                            &#123;</span><br><span class="line">                                xSwitchRequired = pdTRUE;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configUSE_PREEMPTION */</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Tasks of equal priority to the currently running task will share</span></span><br><span class="line"><span class="comment">        * processing time (time slice) if preemption is on, and the application</span></span><br><span class="line"><span class="comment">        * writer has not explicitly turned time slicing off. */</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configUSE_TIME_SLICING == 1 ) )</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( listCURRENT_LIST_LENGTH( &amp;( pxReadyTasksLists[ pxCurrentTCB-&gt;uxPriority ] ) ) &gt; ( UBaseType_t ) <span class="number">1</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    xSwitchRequired = pdTRUE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configUSE_TIME_SLICING == 1 ) ) */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> ( configUSE_TICK_HOOK == 1 )</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* Guard against the tick hook being called when the pended tick</span></span><br><span class="line"><span class="comment">                * count is being unwound (when the scheduler is being unlocked). */</span></span><br><span class="line">                <span class="keyword">if</span>( xPendedTicks == ( TickType_t ) <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    vApplicationTickHook();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configUSE_TICK_HOOK */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> ( configUSE_PREEMPTION == 1 )</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( xYieldPending != pdFALSE )</span><br><span class="line">                &#123;</span><br><span class="line">                    xSwitchRequired = pdTRUE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configUSE_PREEMPTION */</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ++xPendedTicks;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* The tick hook gets called at regular intervals, even if the</span></span><br><span class="line"><span class="comment">        * scheduler is locked. */</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> ( configUSE_TICK_HOOK == 1 )</span></span><br><span class="line">            &#123;</span><br><span class="line">                vApplicationTickHook();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xSwitchRequired;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="4-FreeRTOS-tickcount溢出处理"><a href="#4-FreeRTOS-tickcount溢出处理" class="headerlink" title="4 FreeRTOS tickcount溢出处理"></a>4 FreeRTOS tickcount溢出处理</h2><p>上文提到了FreeRTOSS的<code>xTickCount</code> 类型是32bit的，按照1ms一次tick中断，大约在50天后就会溢出，FreeRTOS对tick cnt溢出做了处理。</p>
<p>FreeRTOS会创建两个delay相关的task：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PRIVILEGED_DATA <span class="type">static</span> List_t * <span class="keyword">volatile</span> pxDelayedTaskList;              <span class="comment">/*&lt; Points to the delayed task list currently being used. */</span></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> List_t * <span class="keyword">volatile</span> pxOverflowDelayedTaskList;      <span class="comment">/*&lt; Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */</span></span><br></pre></td></tr></table></figure>

<p><code>pxDelayedTaskList</code>中维护调用了延时接口的task，其中到期时间并不会溢出；如果到期时间已经发生溢出，将该task添加至<code>pxOverflowDelayedTaskList</code> </p>
<p><img src="/2025/05/04/FreeRTOS-schdule/delaytasklist.png" alt="delay_task_list.png"></p>
<p>下面是<code>xTaskIncrementTick()</code> 的溢出判断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( xConstTickCount == ( TickType_t ) <span class="number">0U</span> ) <span class="comment">/*lint !e774 &#x27;if&#x27; does not always evaluate to false as it is looking for an overflow. */</span></span><br><span class="line">&#123;</span><br><span class="line">    taskSWITCH_DELAYED_LISTS();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>xConstTickCount==0</code> 时，即已经发生溢出，调用<code>taskSWITCH_DELAYED_LISTS();</code> </p>
<p>该宏的具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick</span></span><br><span class="line"><span class="comment"> * count overflows. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskSWITCH_DELAYED_LISTS()                                                \</span></span><br><span class="line"><span class="meta">    &#123;                                                                             \</span></span><br><span class="line"><span class="meta">        List_t * pxTemp;                                                          \</span></span><br><span class="line"><span class="meta">                                                                                  \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* The delayed tasks list should be empty when the lists are switched. */</span> \</span></span><br><span class="line"><span class="meta">        configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );               \</span></span><br><span class="line"><span class="meta">                                                                                  \</span></span><br><span class="line"><span class="meta">        pxTemp = pxDelayedTaskList;                                               \</span></span><br><span class="line"><span class="meta">        pxDelayedTaskList = pxOverflowDelayedTaskList;                            \</span></span><br><span class="line"><span class="meta">        pxOverflowDelayedTaskList = pxTemp;                                       \</span></span><br><span class="line"><span class="meta">        xNumOfOverflows++;                                                        \</span></span><br><span class="line"><span class="meta">        prvResetNextTaskUnblockTime();                                            \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br></pre></td></tr></table></figure>

<p>即当发生溢出后，将<code>pxOverflowDelayedTaskList</code> 和<code>pxDelayedTaskList</code> 进行置换，这样能够保证<code>vTaskDelay()</code> ，但我认为可以直接将<code>pxOverflowDelayedTaskList</code> 清空，因为在task调用延时函数时，已经对溢出做了判断，当前<code>pxDelayedTaskList</code> 不应有为被调起的task。</p>
<h2 id="5-Apendix"><a href="#5-Apendix" class="headerlink" title="5 Apendix"></a>5 Apendix</h2><p>上述问题的前提为无稳定的外部时钟源可选的无奈之举，如果Systick外部有稳定时钟源可选的话，就不存在上述问题，同时，上述对节拍器中断源的重新配置，会导致FreeRTOS原生的tick less mode无法使用（很难适配）。</p>
<p>若有稳定的systick外部时钟，下面是配置方式。</p>
<ol>
<li><p>首先是systick control寄存器描述：<br><img src="/2025/05/04/FreeRTOS-schdule/systick_ctrl_reg.png" alt="systick_ctrl_reg.png"></p>
</li>
<li><p>仅需在<code>FreeRTOSConfig.h</code> 添加SysTick clock的参数即可，<code>vPortSetupTimerInterrupt</code> 函数中的宏定义<code>portNVIC_SYSTICK_CLK_BIT</code> 和<code>configSYSTICK_CLOCK_HZ</code> 也会随之修改，<br>然后在FreeRTOS初始化Systick时，配置<code>SYST_CSR</code>寄存器。</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configSYSTICK_CLOCK_HZ                   32768</span></span><br><span class="line"></span><br><span class="line">__attribute__( ( weak ) ) <span class="type">void</span> <span class="title function_">vPortSetupTimerInterrupt</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Calculate the constants required to configure the tick interrupt. */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_TICKLESS_IDLE == 1 )</span></span><br><span class="line">        &#123;</span><br><span class="line">            ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );</span><br><span class="line">            xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;</span><br><span class="line">            ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configUSE_TICKLESS_IDLE */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Stop and clear the SysTick. */</span></span><br><span class="line">    portNVIC_SYSTICK_CTRL_REG = <span class="number">0UL</span>;</span><br><span class="line">    portNVIC_SYSTICK_CURRENT_VALUE_REG = <span class="number">0UL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Configure SysTick to interrupt at the requested rate. */</span></span><br><span class="line">    portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - <span class="number">1UL</span>;</span><br><span class="line">    portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>FreeRTOS</tag>
      </tags>
  </entry>
  <entry>
    <title>NOTICE</title>
    <url>/2021/07/09/Notice/</url>
    <content><![CDATA[<p><strong>之前电脑数据没了，重新搭建博客，之前文章在恢复中…</strong></p>
]]></content>
  </entry>
  <entry>
    <title>HttpWebSever概述</title>
    <url>/2022/03/11/HttpWebSever/</url>
    <content><![CDATA[<p>根据游双老师的Linux高性能服务器编程做的一个轻量级Linux服务器，项目地址<a href="https://github.com/wangbi0912/light_web_server">GitHub</a></p>
<span id="more"></span>

<h3 id="1、项目概述"><a href="#1、项目概述" class="headerlink" title="1、项目概述"></a>1、项目概述</h3><p><strong>基于Linux的轻量级服务器</strong>，主要目的是学习巩固APUE、UNP卷1、UNP卷2的知识。</p>
<ul>
<li>使用**线程池+epoll+Reactor事件模式(Proactor)**的并发模型</li>
<li>使用**有限状态机(FSM)**解析HTTP请求报文</li>
<li>经过Webbench压力测试能够实现C10K的并发连接</li>
</ul>
<h4 id="1-1-工作流程"><a href="#1-1-工作流程" class="headerlink" title="1.1 工作流程"></a>1.1 工作流程</h4><p>服务器首先创建一个监听<code>socket</code>为<code>listen_fd</code>，并添加到epoll事件表中，浏览器向服务器发起请求连接，首先进行TCP三次握手，服务端监测到<code>listen_fd</code>有事件发生，服务端<code>accept</code>阻塞后返回一个新的<code>socket_fd</code>，并继续添加到内核事件表中。</p>
<ul>
<li><strong>Reactor：</strong>若<code>epoll_wait</code>返回的为<code>socket_fd</code>，主线程将其插入到工作队列，通知线程池处理（读写请求，接受新连接），<strong>通常由同步I&#x2F;O实现</strong></li>
</ul>
<p><img src="https://i.loli.net/2020/05/29/9DlXZPUygOrHbE2.png" alt="Reactor"></p>
<ul>
<li><strong>Proactor：</strong>主线程和内核负责读写数据接受请求，然后将解析后的请求插入到工作队列，由线程池负责业务逻辑，<strong>通常由异步I&#x2F;O实现</strong></li>
</ul>
<p><img src="https://i.loli.net/2020/05/29/lvdktpU5xYXwPTg.png" alt="Proactor"></p>
<blockquote>
<p><strong>也可以使用同步I&#x2F;O模拟Proactor模式，提高服务器并发性能</strong></p>
</blockquote>
<ol>
<li>主线程往epoll内核事件表注册socket上的读就绪事件。</li>
<li>主线程调用epoll_wait等待socket上有数据可读</li>
<li>当socket上有数据可读，epoll_wait通知主线程,主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li>
<li>睡眠在请求队列上某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件</li>
<li>主线程调用epoll_wait等待socket可写。</li>
<li>当socket上有数据可写，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。</li>
</ol>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>malloc、STL空间配置器</title>
    <url>/2022/06/19/malloc%E3%80%81STL%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/</url>
    <content><![CDATA[<blockquote>
<p>malloc一直是困惑我好久的事情，今天记录一下。</p>
</blockquote>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*源码描述</span></span><br><span class="line"><span class="comment">  The main properties of the algorithms are:</span></span><br><span class="line"><span class="comment">  * For large (&gt;= 512 bytes) requests, it is a pure best-fit allocator,</span></span><br><span class="line"><span class="comment">    with ties normally decided via FIFO (i.e. least recently used).</span></span><br><span class="line"><span class="comment">  * For small (&lt;= 64 bytes by default) requests, it is a caching</span></span><br><span class="line"><span class="comment">    allocator, that maintains pools of quickly recycled chunks.</span></span><br><span class="line"><span class="comment">  * In between, and for combinations of large and small requests, it does</span></span><br><span class="line"><span class="comment">    the best it can trying to meet both goals at once.</span></span><br><span class="line"><span class="comment">  * For very large requests (&gt;= 128KB by default), it relies on system</span></span><br><span class="line"><span class="comment">    memory mapping facilities, if supported.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>malloc</code>工作原理<ol>
<li><code>malloc</code>开始搜索空闲内存块，如果能找到一块大小合适的就分配出去</li>
<li>如果<code>malloc</code>找不到一块合适的空闲内存，那么调用brk等系统调用扩大堆区从而获得更多的空闲内存（这里使用<code>brk</code>还是<code>mmap</code>取决于申请的大小）</li>
<li><code>malloc</code>调用<code>brk</code>后开始转入内核态，此时操作系统中的虚拟地址系统开始工作，扩大进程的堆区，操作系统并没有为此分配真正的物理内存</li>
<li><code>brk</code>执行结束后返回到<code>malloc</code>，从内核态切换到用户态，<code>malloc</code>找到一块合适的空闲内存后返回</li>
<li>进程拿到内存，继续干活。</li>
<li>当有代码读写新申请的内存时系统内部出现缺页中断，此时再次由用户态切换到内核态，操作系统此时真正的分配物理内存，之后再次由内核态切换回用户态，程序继续。</li>
</ol>
</li>
</ul>
<hr>
<ul>
<li>SGI STL空间配置器</li>
</ul>
<p>考虑到小型区块可能造成内存碎片问题，SGI 采用两级配置器，第一级配置器直接使用 <code>malloc()</code> 和 <code>free()</code>实现；第二级配置器使用 memory pool 内存池管理。</p>
<p>第二级配置器的原理：</p>
<ul>
<li>当配置区块超过 128 bytes，就使用第一级配置器</li>
<li>当配置区块小于 128 bytes，使用内存池管理</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;_ALIGN = <span class="number">8</span>&#125;;  <span class="comment">// 小型区块的上调边界</span></span><br><span class="line"><span class="keyword">enum</span> &#123;_MAX_BYTES = <span class="number">128</span>&#125;; <span class="comment">// 小区区块的上限</span></span><br><span class="line"><span class="keyword">enum</span> &#123;_NFREELISTS = <span class="number">16</span>&#125;; <span class="comment">// _MAX_BYTES/_ALIGN  free-list 的个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// free-list 的节点结构，降低维护链表 list 带来的额外负担</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">_Obj</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">_Obj</span>* _M_free_list_link;  <span class="comment">// 利用联合体特点</span></span><br><span class="line">    <span class="type">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this. */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> _Obj* __STL_VOLATILE _S_free_list[_NFREELISTS];  <span class="comment">// 注意，它是数组，每个数组元素包含若干相等的小额区块</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>free-list </code>是指针数组，16 个数组元素，就是 16 个 <code>free-list</code>，各自管理大小分别为 8， 16， 24， 32，…128 bytes(8 的倍数)的小额区块。</p>
<p>小额区块的结构体 union _Obj 使用链表连接起来。如图所示：<br><img src="https://upload-images.jianshu.io/upload_images/27610647-53a735a6284192db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>配置器负责配置，同时也负责回收。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>shared_str、String类实现</title>
    <url>/2022/05/11/shared-str%E3%80%81String%E7%B1%BB%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>实现<code>shared_ptr</code>和<code>String</code>类，分析<code>shared_ptr</code>线程安全问题。</p>
<span id="more"></span>

<h2 id="一、shared-ptr使用方法"><a href="#一、shared-ptr使用方法" class="headerlink" title="一、shared_ptr使用方法"></a>一、<code>shared_ptr</code>使用方法</h2><p>使用该智能指针（或者其他两种）需要导入头文件<code>#include &lt;memory&gt;</code></p>
<ul>
<li>创建空指针<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p1;             <span class="comment">//不传入任何实参</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;    <span class="comment">//传入空指针 nullptr</span></span><br></pre></td></tr></table></figure></li>
<li>明确指向<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p4 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);  <span class="comment">//推荐使用make_shared&lt;T&gt;构造</span></span><br></pre></td></tr></table></figure></li>
<li>拷贝构造<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(p3)</span></span>;</span><br></pre></td></tr></table></figure>
除此之外还可以对<code>shared_ptr</code>赋值，通过重写<code>operator=</code>实现。<strong>需要注意</strong>，对于<code>p1=p2</code>（均为智能指针）这种，<code>p2</code>所指对象由于被<code>p1</code>指向，所以该引用计数会加一，<code>p1</code>原本指向的资源的引用计数会减一。这也会引出下面关于<code>shared_ptr</code>指针的<strong>线程安全</strong>问题。</li>
</ul>
<hr>
<h2 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存在问题：引用计数不增加</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//已解决：重载()函数换成拷贝构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mShared_ptr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _ptr;</span><br><span class="line">    <span class="type">int</span>* _refcount;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mShared_ptr</span>() : _ptr(<span class="keyword">new</span> <span class="built_in">T</span>()), _refcount(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mShared_ptr</span>(T* obj) : _ptr(obj), _refcount(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">mShared_ptr</span>() &#123;</span><br><span class="line">        --(*_refcount);</span><br><span class="line">        <span class="keyword">if</span>(_ptr &amp;&amp; (*_refcount) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">            <span class="keyword">delete</span> _refcount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mShared_ptr</span> (<span class="type">const</span> mShared_ptr&amp; _other) &#123;</span><br><span class="line">        ++*_other._refcount;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;_ref : &quot;</span> &lt;&lt; *_other._refcount &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_ptr = _other._ptr;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_refcount = _other._refcount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mShared_ptr&amp; <span class="keyword">operator</span>= (<span class="type">const</span> mShared_ptr&amp; _other) &#123;</span><br><span class="line">        <span class="keyword">if</span>(_other == *<span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        --*(<span class="keyword">this</span>-&gt;_refcount);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;_ptr &amp;&amp; *(<span class="keyword">this</span>-&gt;_refcount) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_refcount;</span><br><span class="line">        &#125;</span><br><span class="line">        ++*_other._refcount;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;_ref : &quot;</span> &lt;&lt; *_other._refcount &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_ptr = _other._ptr;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_refcount = _other._refcount;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>* () &#123;</span><br><span class="line">        <span class="keyword">return</span> *_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt; () &#123;</span><br><span class="line">        <span class="keyword">return</span> _ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_refcount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_refcount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">mShared_ptr&lt;<span class="type">int</span>&gt; <span class="title">obj</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    mShared_ptr&lt;<span class="type">int</span>&gt; obj2 = obj;</span><br><span class="line">    <span class="function">mShared_ptr&lt;<span class="type">int</span>&gt; <span class="title">obj3</span><span class="params">(obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; *obj &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *obj2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *obj3 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; obj.<span class="built_in">get_refcount</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; obj2.<span class="built_in">get_refcount</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; obj3.<span class="built_in">get_refcount</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">root@iZuf6ccxsb4mprtz1c1mx2Z:~/<span class="title">Linux</span>/<span class="title">Test</span>/<span class="title">DataStructure</span># ./<span class="title">mShared_ptr</span> </span></span><br><span class="line"><span class="function"><span class="title">_ref</span> : 2</span></span><br><span class="line"><span class="function"><span class="title">_ref</span> : 3</span></span><br><span class="line"><span class="function">10</span></span><br><span class="line"><span class="function">10</span></span><br><span class="line"><span class="function">10</span></span><br><span class="line"><span class="function">3</span></span><br><span class="line"><span class="function">3</span></span><br><span class="line"><span class="function">3</span></span><br></pre></td></tr></table></figure>
<p>这里实现的还有一些问题，因为<code>shared_ptr</code>源码中关于引用计数是<strong>原子操作</strong>，不需要考虑资源使用冲突的问题，可以在自己实现的时候加锁。</p>
<hr>
<h2 id="三、关于shared-ptr的线程安全问题"><a href="#三、关于shared-ptr的线程安全问题" class="headerlink" title="三、关于shared_ptr的线程安全问题"></a>三、关于<code>shared_ptr</code>的线程安全问题</h2><p>首先什么是线程安全？<br>简单来说就是<strong>多个线程操作一个共享数据，都能按照预期的行为进行，无论多个线程的运行次序如何交织。</strong></p>
<p>对于<code>shared_ptr</code>，其内部有两个变量，引用计数和真正的对象类型指针。其中引用计数是原子操作，所以<strong>对于<code>shared_ptr</code>的读操作是线程安全的。</strong></p>
<p>但是对于<code>shared_ptr</code>中赋值如<code>ptr1 = ptr2</code>，需要两个步骤，<strong>1、<code>ptr1</code>的内部对象指针<code>Obj1</code>替换成<code>ptr2</code>内部对象<code>Obj2</code>指针；2、<code>ptr1</code>的对于<code>Obj1</code>的引用计数缓存<code>Obj2</code>的引用计数。</strong></p>
<p>这两步并不是原子的，如果一个线程需要对<code>shared_ptr</code>进行赋值操作<code>ptr1 = ptr2</code>，刚完成第一步，就切换到其他线程又对ptr2进行操作，如<code>ptr2 = ptr3</code>，就有可能造成析构了引用计数。而继续之前线程的第二步，就会出错。</p>
<p><strong>总之：对于<code>shared_ptr</code>的读操作是线程安全的。<br>对于<code>shared_ptr</code>读写操作不是线程安全的，需要加锁。</strong></p>
<hr>
<p>tips：为什么<code>shared_ptr</code>的引用计数能够同步到不同的指针中？</p>
<p>有人回答可能使用的是static变量，这是不可能的，因为一个类中只有一个静态变量，只能记录对于一个对象的引用次数，这在包含两个<code>shared_ptr</code>以上的程序中是不可行的。<br>个人认为是引用计数是用指针实现的，指向一个记录引用次数的对象。</p>
<hr>
<h2 id="四、String类实现"><a href="#四、String类实现" class="headerlink" title="四、String类实现"></a>四、String类实现</h2><h2 id="String和strcpy函数"><a href="#String和strcpy函数" class="headerlink" title="String和strcpy函数"></a>String和strcpy函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现string类</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mString</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* _data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mString</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            _data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(_data, str);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _data = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">            *_data = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mString</span>(<span class="type">const</span> mString&amp; str) &#123;</span><br><span class="line">        _data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str._data) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_data, str._data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mString&amp; <span class="keyword">operator</span>= (<span class="type">const</span> mString&amp; str) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;_data == str._data) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;_data;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str._data) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;_data, str._data);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">mString</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] _data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">mString <span class="title">str1</span><span class="params">(<span class="string">&quot;woshinidie&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">mString <span class="title">str2</span><span class="params">(str1)</span></span>;</span><br><span class="line">    mString str3 = str1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; str1.<span class="built_in">data</span>()[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; str2.<span class="built_in">data</span>()[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; str3.<span class="built_in">data</span>()[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现strcpy函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">mStrcpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!dest || !source)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>((*dest++ = *source++) != <span class="string">&#x27;\0&#x27;</span>) &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> s2[<span class="number">20</span>] = <span class="string">&quot;fashdfk&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* s1 = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s2) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">mStrcpy</span>(s1, s2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; s1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>webserver基本知识</title>
    <url>/2022/03/27/webserver%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="1、基础知识"><a href="#1、基础知识" class="headerlink" title="1、基础知识"></a>1、基础知识</h2><h4 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a><strong>RAII</strong></h4><span id="more"></span>

<ul>
<li>RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”.</li>
<li>在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定</li>
<li>RAII的核心思想是将资源或者状态与对象的生命周期绑定，通过C++的语言机制，实现资源和状态的安全管理,智能指针是RAII最好的例子</li>
</ul>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a><strong>信号量</strong></h4><p>信号量是一种特殊的变量，它只能取自然数值并且只支持两种操作：等待(P)和信号(V).假设有信号量SV，对其的P、V操作如下：</p>
<blockquote>
<ul>
<li>P，如果SV的值大于0，则将其减一；若SV的值为0，则挂起执行</li>
<li>V，如果有其他进行因为等待SV而挂起，则唤醒；若没有，则将SV值加一</li>
</ul>
</blockquote>
<p>信号量的取值可以是任何自然数，最常用的，最简单的信号量是二进制信号量，只有0和1两个值.</p>
<blockquote>
<ul>
<li>sem_init函数用于初始化一个未命名的信号量</li>
<li>sem_destory函数用于销毁信号量</li>
<li>sem_wait函数将以原子操作方式将信号量减一,信号量为0时,sem_wait阻塞</li>
<li>sem_post函数以原子操作方式将信号量加一,信号量大于0时,唤醒调用sem_post的线程</li>
</ul>
</blockquote>
<p>以上，成功返回0，失败返回errno</p>
<h4 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a><strong>互斥量</strong></h4><p>互斥锁,也成互斥量,可以保护关键代码段,以确保独占式访问.当进入关键代码段,获得互斥锁将其加锁;离开关键代码段,唤醒等待该互斥锁的线程.</p>
<blockquote>
<ul>
<li>pthread_mutex_init函数用于初始化互斥锁</li>
<li>pthread_mutex_destory函数用于销毁互斥锁</li>
<li>pthread_mutex_lock函数以原子操作方式给互斥锁加锁</li>
<li>pthread_mutex_unlock函数以原子操作方式给互斥锁解锁</li>
</ul>
</blockquote>
<p>以上，成功返回0，失败返回errno</p>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a><strong>条件变量</strong></h4><p>条件变量提供了一种线程间的通知机制,当某个共享数据达到某个值时,唤醒等待这个共享数据的线程.</p>
<blockquote>
<ul>
<li>pthread_cond_init函数用于初始化条件变量</li>
<li>pthread_cond_destory函数销毁条件变量</li>
<li>pthread_cond_broadcast函数以广播的方式唤醒<strong>所有</strong>等待目标条件变量的线程</li>
<li>pthread_cond_wait函数用于等待目标条件变量.该函数调用时需要传入 <strong>mutex参数(加锁的互斥锁)</strong> ,函数执行时,先把调用线程放入条件变量的请求队列,然后将互斥锁mutex解锁,当函数成功返回为0时,互斥锁会再次被锁上. <strong>也就是说函数内部会有一次解锁和加锁操作</strong>.</li>
</ul>
</blockquote>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><h4 id="锁机制的功能"><a href="#锁机制的功能" class="headerlink" title="锁机制的功能"></a><strong>锁机制的功能</strong></h4><ul>
<li>实现多线程同步，通过锁机制，确保任一时刻只能有一个线程能进入关键代码段.</li>
</ul>
<h4 id="封装的功能"><a href="#封装的功能" class="headerlink" title="封装的功能"></a><strong>封装的功能</strong></h4><ul>
<li>类中主要是Linux下三种锁进行封装，将锁的创建于销毁函数封装在类的构造与析构函数中，实现RAII机制</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 1class sem&#123;</span><br><span class="line"> 2    public:</span><br><span class="line"> 3        //构造函数</span><br><span class="line"> 4        sem()</span><br><span class="line"> 5        &#123;</span><br><span class="line"> 6            //信号量初始化</span><br><span class="line"> 7            if(sem_init(&amp;m_sem,0,0)!=0)&#123;</span><br><span class="line"> 8                throw std::exception();</span><br><span class="line"> 9            &#125;</span><br><span class="line">10        &#125;</span><br><span class="line">11        //析构函数</span><br><span class="line">12        ~sem()</span><br><span class="line">13        &#123;</span><br><span class="line">14            //信号量销毁</span><br><span class="line">15            sem_destroy(&amp;m_sem);</span><br><span class="line">16        &#125;</span><br><span class="line">17    private:</span><br><span class="line">18        sem_t m_sem;</span><br><span class="line">19&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>将重复使用的代码封装为函数，减少代码的重复，使其更简洁</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 1   //条件变量的使用机制需要配合锁来使用</span><br><span class="line"> 2   //内部会有一次加锁和解锁</span><br><span class="line"> 3   //封装起来会使得更加简洁</span><br><span class="line"> 4   bool wait()</span><br><span class="line"> 5   &#123;</span><br><span class="line"> 6       int ret=0;</span><br><span class="line"> 7       pthread_mutex_lock(&amp;m_mutex);</span><br><span class="line"> 8       ret=pthread_cond_wait(&amp;m_cond,&amp;m_mutex);</span><br><span class="line"> 9       pthread_mutex_unlock(&amp;m_mutex);</span><br><span class="line">10       return ret==0;</span><br><span class="line">11   &#125;</span><br><span class="line">12   bool signal()</span><br><span class="line">13   &#123;</span><br><span class="line">14       return pthread_cond_signal(&amp;m_cond)==0;</span><br><span class="line">15   &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2、半同步半异步-线程池"><a href="#2、半同步半异步-线程池" class="headerlink" title="2、半同步半异步+线程池"></a>2、半同步半异步+线程池</h2><h3 id="服务器编程基本框架"><a href="#服务器编程基本框架" class="headerlink" title="服务器编程基本框架"></a>服务器编程基本框架</h3><p>主要由I&#x2F;O单元，逻辑单元和网络存储单元组成，其中每个单元之间通过请求队列进行通信，从而协同完成任务。</p>
<p>其中I&#x2F;O单元用于处理客户端连接，读写网络数据；逻辑单元用于处理业务逻辑的线程；网络存储单元指本地数据库和文件等。</p>
<p><img src="https://i.loli.net/2020/05/29/iVTuxoOaQvYcSrA.png" alt="image-20200529181932994"></p>
<h3 id="五种I-x2F-O模型"><a href="#五种I-x2F-O模型" class="headerlink" title="五种I&#x2F;O模型"></a>五种I&#x2F;O模型</h3><ul>
<li><strong>阻塞IO</strong>:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作</li>
<li><strong>非阻塞IO</strong>:非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I&#x2F;O执行系统调用总是立即返回，不管时间是否已经发生，若时间没有发生，则返回-1，此时可以根据errno区分这两种情况，对于accept，recv和send，事件未发生时，errno通常被设置成eagain</li>
<li><strong>信号驱动IO</strong>:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。</li>
<li><strong>IO复用</strong>:linux用select&#x2F;poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数</li>
<li><strong>异步IO</strong>:linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</li>
</ul>
<p><strong>注意：阻塞I&#x2F;O，非阻塞I&#x2F;O，信号驱动I&#x2F;O和I&#x2F;O复用都是同步I&#x2F;O。同步I&#x2F;O指内核向应用程序通知的是就绪事件，比如只通知有客户端连接，要求用户代码自行执行I&#x2F;O操作，异步I&#x2F;O是指内核向应用程序通知的是完成事件，比如读取客户端的数据后才通知应用程序，由内核完成I&#x2F;O操作。</strong></p>
<h3 id="事件处理模式"><a href="#事件处理模式" class="headerlink" title="事件处理模式"></a>事件处理模式</h3><ul>
<li>reactor模式中，主线程(<strong>I&#x2F;O处理单元</strong>)只负责监听文件描述符上是否有事件发生，有的话立即通知工作线程(<strong>逻辑单元</strong> )，读写数据、接受新连接及处理客户请求均在工作线程中完成。通常由<strong>同步I&#x2F;O</strong>实现。</li>
</ul>
<p><img src="https://i.loli.net/2020/05/29/9DlXZPUygOrHbE2.png" alt="image-20200529182048896"></p>
<ul>
<li>proactor模式中，主线程和内核负责处理读写数据、接受新连接等I&#x2F;O操作，工作线程仅负责业务逻辑，如处理客户请求。通常由<strong>异步I&#x2F;O</strong>实现。</li>
</ul>
<p><img src="https://i.loli.net/2020/05/29/lvdktpU5xYXwPTg.png" alt="image-20200529182104068"></p>
<h3 id="同步I-x2F-O模拟proactor模式"><a href="#同步I-x2F-O模拟proactor模式" class="headerlink" title="同步I&#x2F;O模拟proactor模式"></a>同步I&#x2F;O模拟proactor模式</h3><p>由于异步I&#x2F;O并不成熟，实际中使用较少，这里将使用同步I&#x2F;O模拟实现proactor模式。</p>
<p>同步I&#x2F;O模型的工作流程如下（epoll_wait为例）：</p>
<blockquote>
<ul>
<li>主线程往epoll内核事件表注册socket上的读就绪事件。</li>
<li>主线程调用epoll_wait等待socket上有数据可读</li>
<li>当socket上有数据可读，epoll_wait通知主线程,主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li>
<li>睡眠在请求队列上某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件</li>
<li>主线程调用epoll_wait等待socket可写。</li>
<li>当socket上有数据可写，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。</li>
</ul>
</blockquote>
<p><img src="https://i.loli.net/2020/05/29/pWNfHEBucjs5JVm.png" alt="image-20200529182127823"></p>
<h3 id="并发编程模式"><a href="#并发编程模式" class="headerlink" title="并发编程模式"></a>并发编程模式</h3><p>并发编程方法的实现有多线程和多进程两种，但这里涉及的并发模式指I&#x2F;O处理单元与逻辑单元的协同完成任务的方法。</p>
<ul>
<li>半同步&#x2F;半异步模式</li>
<li>领导者&#x2F;追随者模式</li>
</ul>
<h3 id="半同步-x2F-半反应堆"><a href="#半同步-x2F-半反应堆" class="headerlink" title="半同步&#x2F;半反应堆"></a>半同步&#x2F;半反应堆</h3><p>半同步&#x2F;半反应堆并发模式是半同步&#x2F;半异步的变体，将半异步具体化为某种事件处理模式.</p>
<p>并发模式中的同步和异步</p>
<blockquote>
<ul>
<li>同步指的是程序完全按照代码序列的顺序执行</li>
<li>异步指的是程序的执行需要由系统事件驱动</li>
</ul>
</blockquote>
<p><img src="https://i.loli.net/2020/05/29/Fm5ZJfUShDcNWov.png" alt="image-20200529182211696"></p>
<p>半同步&#x2F;半异步模式工作流程</p>
<blockquote>
<ul>
<li>同步线程用于处理客户逻辑</li>
<li>异步线程用于处理I&#x2F;O事件</li>
<li>异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中</li>
<li>请求队列将通知某个工作在<strong>同步模式的工作线程</strong>来读取并处理该请求对象</li>
</ul>
</blockquote>
<p><img src="https://i.loli.net/2020/05/29/lRNaU6hMACiWdg7.png" alt="image-20200529182234142"></p>
<p>半同步&#x2F;半反应堆工作流程（以Proactor模式为例）</p>
<blockquote>
<ul>
<li>主线程充当异步线程，负责监听所有socket上的事件</li>
<li>若有新请求到来，主线程接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件</li>
<li>如果连接socket上有读写事件发生，主线程从socket上接收数据，并将数据封装成请求对象插入到请求队列中</li>
<li>所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权</li>
</ul>
</blockquote>
<p><img src="https://i.loli.net/2020/05/29/9s5Vz8nThU6jD4X.png" alt="image-20200529182418750"></p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul>
<li>空间换时间,浪费服务器的硬件资源,换取运行效率.</li>
<li>池是一组资源的集合,这组资源在服务器启动之初就被完全创建好并初始化,这称为静态资源.</li>
<li>当服务器进入正式运行阶段,开始处理客户请求的时候,如果它需要相关的资源,可以直接从池中获取,无需动态分配.</li>
<li>当服务器处理完一个客户连接后,可以把相关的资源放回池中,无需执行系统调用释放资源.</li>
</ul>
<blockquote>
<p> 线程池实现可以见我另外一篇博客</p>
</blockquote>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树（一）</title>
    <url>/2021/06/12/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h3 id="文章对应的题目"><a href="#文章对应的题目" class="headerlink" title="文章对应的题目"></a>文章对应的题目</h3><p>230  BST第K小的元素<br>538  二叉搜索树转化为累加树</p>
<span id="more"></span>

<hr>
<h3 id="二叉搜索树BST特性："><a href="#二叉搜索树BST特性：" class="headerlink" title="二叉搜索树BST特性："></a>二叉搜索树BST特性：</h3><p>1、对于BST上每个节点<code>node</code>，左子树的节点的值都比<code>node</code>的值要小，右子树节点的值都比<code>node</code>的值要大。<br>2、对于BST的每一个节点<code>node</code>，他的左侧子树<code>node -&gt; left</code>和右侧子树<code>node -&gt; right</code>都为BST。<br>3、对BST做<strong>中序遍历</strong>，得到的遍历结果是<strong>升序</strong>的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对BST做中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traverse</span>(root -&gt; left);</span><br><span class="line">    cout &lt;&lt; root -&gt; val &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">traverse</span>(root -&gt; right);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="230-寻找第K小的元素"><a href="#230-寻找第K小的元素" class="headerlink" title="230. 寻找第K小的元素"></a>230. 寻找第K小的元素</h1><p><img src="/2021/06/12/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88%E4%B8%80%EF%BC%89/230.png" alt="230. 寻找第K小的元素"><br>题目需求如上，直接思路就是中序遍历，找到排名第K的元素，代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> res= <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traverse</span>(root, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traverse</span>(root -&gt; left, k);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i == k) &#123;</span><br><span class="line">            res = root -&gt; val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traverse</span>(root -&gt; right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为<code>O(N)</code>，像红黑树这种自平衡的BST，增删查改时间复杂度都是对数级的<code>O(logN)</code>，所以说有点低效。<br>若要达到对数级的时间复杂度，就需要知道当前的节点的排名是多少（类似于二分查找）。<br>比如说你让我查找排名为k的元素，当前节点知道自己排名第<code>m</code>，那么我可以比较<code>m</code>和<code>k</code>的大小：</p>
<p>1、如果<code>m == k</code>，显然就是找到了第<code>k</code>个元素，返回当前节点就行了。<br>2、如果<code>k &lt; m</code>，那说明排名第k的元素在左子树，所以可以去左子树搜索第<code>k</code>个元素。<br>3、如果<code>k &gt; m</code>，那说明排名第k的元素在右子树，所以可以去右子树搜索第<code>k - m - 1</code>个元素。</p>
<p>这样就可以将时间复杂度降到<code>O(logN)</code>了。这就需要在二叉树节点中维护一个排名信息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     <span class="comment">//size为当前节点为根节点的树的节点总数</span></span><br><span class="line">     <span class="type">int</span> size;</span><br><span class="line">     TreeNode *left;</span><br><span class="line">     TreeNode *right;</span><br><span class="line">     <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>这样就可以将排名<code>k</code>和<code>node -&gt; left -&gt; size</code>对比，达到对数级的时间复杂度。</p>
<hr>
<h3 id="二叉搜索树转化为累加树"><a href="#二叉搜索树转化为累加树" class="headerlink" title="二叉搜索树转化为累加树"></a>二叉搜索树转化为累加树</h3><p><img src="/2021/06/12/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88%E4%B8%80%EF%BC%89/538.png" alt="二叉搜索树转化为累加树"><br>其实就是利用二叉树的中序遍历特性，本题直接利用降序输出即可，递归顺序为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == nullprt)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traverse</span>(root -&gt; right);</span><br><span class="line">    cout &lt;&lt; root -&gt; val &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">traverse</span>(root -&gt; left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码可以从大到小降序打印 BST 节点的值，如果维护一个外部累加变量<code>sum</code>，然后把<code>sum</code>赋值给 BST 中的每一个节点，就可以将 BST 转化成累加树。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">GST</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">GST</span>(root -&gt; right);</span><br><span class="line">        sum += root -&gt; val;</span><br><span class="line">        root -&gt; val = sum;</span><br><span class="line">        <span class="built_in">GST</span>(root -&gt; left);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>[labuladong公众号](<a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247488101&idx=1&sn=6041ddda5f20ccde8a7036d3e3a1482c&chksm=9bd7ec6daca0657b2ab20a936437e2c8206384c3b1485fe91747ad796fa3a5b08556b2f4911e&scene=21#wechat_redirect">手把手刷二叉搜索树（第一期） (qq.com)</a>)</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树（三）</title>
    <url>/2021/06/15/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h3 id="文章对应的题目"><a href="#文章对应的题目" class="headerlink" title="文章对应的题目"></a>文章对应的题目</h3><p>96 不同的二叉搜索树<br>95 不同的二叉搜索树II</p>
<span id="more"></span>

<hr>
<h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96.不同的二叉搜索树"></a>96.不同的二叉搜索树</h3><p><img src="https://upload-images.jianshu.io/upload_images/27610647-fb884c22652bbbb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="96.不同的二叉搜索树"><br>若输入<code>n=3</code>，总共有5种BST，结果为5，这就需要<strong>穷举</strong>。<br>若<code>n=5</code>，或者说用<code>&#123;1, 2, 3, 4, 5&#125;</code>构造平衡二叉树，首先每一个点都能作为根节点，若我们固定<code>3</code>为根节点，左子树为<code>&#123;1, 2&#125;</code>，右子树为<code>&#123;4, 5&#125;</code>，左右两棵子树分别有2种情况。所以对于固定<code>3</code>为根节点这个情况来讲，共有<strong>2x2&#x3D;4</strong>种结果.<br>对于如何计算左子树<code>&#123;1, 2&#125;</code>、右子树<code>&#123;4, 5&#125;</code>的情况，这是一个计算树的组合的子问题，直接用递归即可。需要一个辅助函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span></span>;  <span class="comment">//闭区间[low, high]的数字能组成count(low, high)种BST</span></span><br></pre></td></tr></table></figure>
<p>具体实现代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">count</span>(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &gt; high)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> mid = low; mid &lt;= high; mid++) &#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="built_in">count</span>(low, mid - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> right = <span class="built_in">count</span>(mid + <span class="number">1</span>, high);</span><br><span class="line">            res += left * right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>提交之后并不能通过，超出时间限制，因为存在<strong>重叠子问题</strong>，在动态规划中消除重叠子问题的方法，就是加一个<strong>备忘录</strong><code>memo</code>。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n)); <span class="comment">//初始化二维vector，每一个元素都为0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">count</span>(<span class="number">1</span>, n, memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &gt; high)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(memo[low - <span class="number">1</span>][high - <span class="number">1</span>] !=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[low - <span class="number">1</span>][high - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> mid = low; mid &lt;= high; mid++) &#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="built_in">count</span>(low, mid - <span class="number">1</span>, memo);</span><br><span class="line">            <span class="type">int</span> right = <span class="built_in">count</span>(mid + <span class="number">1</span>, high, memo);</span><br><span class="line">            res += left * right;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[low - <span class="number">1</span>][high - <span class="number">1</span>] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是提交之后还是超过时间限制…</p>
<hr>
<h3 id="95-不同的二叉搜索树II"><a href="#95-不同的二叉搜索树II" class="headerlink" title="95.不同的二叉搜索树II"></a>95.不同的二叉搜索树II</h3><p>此题思路和上题一样，都是遍历每一个节点作为根节点，迭代求出以当前点为根节点其他子树的树的形状。<br>具体的步骤为：</p>
<ol>
<li>穷举<code>root</code>节点的所有可能。</li>
<li>递归构造左右子树的BST。</li>
<li>穷举左右子树作为<code>root</code>的左右子树<br>具体代码如下<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(<span class="number">1</span>, n);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">build</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &gt; high) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;TreeNode*&gt; res;    <span class="comment">//保存当前root节点的结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> mid = low; mid &lt;= high; mid ++) &#123;</span><br><span class="line">            vector&lt;TreeNode*&gt; left = <span class="built_in">build</span>(low, mid - <span class="number">1</span>);</span><br><span class="line">            vector&lt;TreeNode*&gt; right = <span class="built_in">build</span>(mid + <span class="number">1</span>, high);</span><br><span class="line">            <span class="comment">//给root节点穷举所有所有子树的组合</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i : left) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> j : right) &#123;</span><br><span class="line">                    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(mid);</span><br><span class="line">                    root -&gt; left = i;</span><br><span class="line">                    root -&gt; right = j;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树（二）</title>
    <url>/2021/06/14/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h3 id="文章对应的题目"><a href="#文章对应的题目" class="headerlink" title="文章对应的题目"></a>文章对应的题目</h3><p>450 删除BST的节点（M）<br>701 二叉搜索树的插入操作（M）<br>700 二叉搜索树的搜索（E）<br>98 验证二叉搜索树</p>
<span id="more"></span>

<hr>
<p>对于BST相关的问题，基本上有一个代码框架</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root -&gt; val == target) &#123;</span><br><span class="line">        <span class="comment">//找到目标操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root -&gt; val &lt; target) &#123;</span><br><span class="line">        <span class="built_in">traverse</span>(root -&gt; right, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root -&gt; val &gt; target) &#123;</span><br><span class="line">        <span class="built_in">traverse</span>(root -&gt; left, target);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h3><p><img src="https://upload-images.jianshu.io/upload_images/27610647-9783181e5d62b6b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="98.验证二叉搜索树"></p>
<p>首先，直接思路就是递归遍历每一个节点，比较节点的左右孩子的值和本身相比，<br>但是，二叉搜索树不仅仅是对于一个节点的孩子节点相比，还要保证整个子树都要小于该节点的值，这时候需要一个辅助函数，函数签名为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_valid</span><span class="params">(TreeNode* root, TreeNode* max, TreeNode* min)</span></span>;</span><br></pre></td></tr></table></figure>
<p>辅助函数将该节点作为后续遍历节点的根节点，遍历到左子树时为<code>root</code>为<code>max</code>节点，遍历到右子树时为<code>root</code>为<code>min</code>节点。<br>正确的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValid</span>(root, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(TreeNode* root,TreeNode* max,TreeNode* min)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(max != <span class="literal">nullptr</span> &amp;&amp; root -&gt; val &gt;= max -&gt; val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(min != <span class="literal">nullptr</span> &amp;&amp; root -&gt; val &lt;= min -&gt; val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValid</span>(root -&gt; left, root, min) &amp;&amp; <span class="built_in">isValid</span>(root -&gt; right, max, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用辅助函数增加携带的参数信息，将约束传递到子树的所有节点，这是个小技巧。</p>
<hr>
<h3 id="700-二叉搜索树的搜索（E）"><a href="#700-二叉搜索树的搜索（E）" class="headerlink" title="700 二叉搜索树的搜索（E）"></a>700 二叉搜索树的搜索（E）</h3><p><img src="https://upload-images.jianshu.io/upload_images/27610647-544da1606b2d1135.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="700 二叉搜索树的搜索"></p>
<p>这题比较简单，直接递归就行，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//可以省略判别相等的情况</span></span><br><span class="line">        <span class="comment">// if(root -&gt; val == val)</span></span><br><span class="line">        <span class="comment">//     return root;</span></span><br><span class="line">        <span class="keyword">if</span>(root -&gt; val &gt; val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(root -&gt; left, val);</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; val &lt; val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(root -&gt; right, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="701-二叉搜索树的插入操作"><a href="#701-二叉搜索树的插入操作" class="headerlink" title="701 二叉搜索树的插入操作"></a>701 二叉搜索树的插入操作</h3><p><img src="https://upload-images.jianshu.io/upload_images/27610647-72a3d334adccdb60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="701 二叉搜索树的插入操作"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; val &gt; val)</span><br><span class="line">            root -&gt; left = <span class="built_in">insertIntoBST</span>(root -&gt; left, val);</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; val &lt; val)</span><br><span class="line">            root -&gt; right = <span class="built_in">insertIntoBST</span>(root -&gt; right, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; val &gt; val)</span><br><span class="line">            root -&gt; left = <span class="built_in">insertIntoBST</span>(root -&gt; left, val);</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; val &lt; val)</span><br><span class="line">            root -&gt; right = <span class="built_in">insertIntoBST</span>(root -&gt; right, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="450-删除BST的节点"><a href="#450-删除BST的节点" class="headerlink" title="450 删除BST的节点"></a>450 删除BST的节点</h3><p><img src="https://upload-images.jianshu.io/upload_images/27610647-5ad6ea611902cade.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="450 删除BST的节点"><br>要删除二叉搜索树中的节点，必须要保证删除之后二叉搜索树保持原有性质。删除节点可以分为三种情况：</p>
<ul>
<li>1、删除的节点为叶子节点，左右孩子都为<code>nullptr</code>；<br>  这种情况，直接返回<code>nullptr</code>作为上一个递归的子树；</li>
<li>2、删除的节点只有一个孩子，另一个孩子为<code>nullptr</code>；<br>  这种情况，直接返回其唯一的孩子作为上一个递归的子树；</li>
<li>3、删除的节点有两个孩子<br>  在此情况下，为了不破坏二叉搜索树的性质，必须找到该节点<code>node</code>的左子树<code>node -&gt; left</code>中的最大节点<code>maxNode</code>或右子树<code>node -&gt; right</code>中的最小节点<code>minNode</code>代替该节点，然后递归的删除其右子树<code>node -&gt; right</code>中的<code>minNode</code>（以<code>minNode</code>为例子）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; val == key) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root -&gt; left == <span class="literal">nullptr</span> &amp;&amp; root -&gt; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span>(root -&gt; left != <span class="literal">nullptr</span> &amp;&amp; root -&gt; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> root -&gt; left;</span><br><span class="line">            <span class="keyword">if</span>(root -&gt; left == <span class="literal">nullptr</span> &amp;&amp; root -&gt; right != <span class="literal">nullptr</span>) <span class="keyword">return</span> root -&gt; right;</span><br><span class="line">            TreeNode* temp = <span class="built_in">getMax</span>(root -&gt; right);</span><br><span class="line">            root -&gt; val = temp -&gt; val;</span><br><span class="line">            <span class="comment">//删除右子树的最小节点</span></span><br><span class="line">            root -&gt; right = <span class="built_in">deleteNode</span>(root -&gt; right, temp -&gt; val);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; val &gt; key) &#123;</span><br><span class="line">            root -&gt; left = <span class="built_in">deleteNode</span>(root -&gt; left, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; val &lt; key) &#123;</span><br><span class="line">            root -&gt; right = <span class="built_in">deleteNode</span>(root -&gt; right, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取右子树的最小节点</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">getMax</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root -&gt; left) &#123;</span><br><span class="line">            root = root -&gt; left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式线程安全问题</title>
    <url>/2022/04/07/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>Singleton 实现</p>
</blockquote>
<span id="more"></span>

<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式的实现分为懒汉和饿汉两种实现方法</p>
<ul>
<li><strong>懒汉模式：第一次用到该实例才初始化。</strong></li>
<li><strong>饿汉模式：实例创建即初始化。</strong></li>
</ul>
<blockquote>
<p>单例模式注意事项：构造函数设置为<code>private</code>；拷贝构造和<code>operator=</code>使用<code>c++11</code>的默认函数控制<code>=delete</code>（这种默认函数控制只能使用在默认构造、拷贝构造，operator&#x3D;当中）；类内的静态变量只能类内声明类外定义。</p>
</blockquote>
<hr>
<h3 id="饿汉实现"><a href="#饿汉实现" class="headerlink" title="饿汉实现"></a>饿汉实现</h3><p>饿汉实现较为简单，给出代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>= (<span class="type">const</span> Singleton&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">// static Singleton* m_interface;</span></span><br><span class="line">    <span class="type">static</span> shared_ptr&lt;Singleton&gt; m_interface;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Singleton</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;deconstructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> shared_ptr&lt;Singleton&gt; <span class="title">get_interface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_interface;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">shared_ptr&lt;Singleton&gt; Singleton::m_interface = <span class="built_in">shared_ptr</span>&lt;Singleton&gt;(<span class="keyword">new</span> <span class="built_in">Singleton</span>());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">worker</span><span class="params">(<span class="type">void</span>* args)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sleep&quot;</span> &lt;&lt; endl;</span><br><span class="line">    shared_ptr&lt;Singleton&gt; ptr = Singleton::<span class="built_in">get_interface</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> m_thread[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(m_thread+i, <span class="literal">NULL</span>, worker, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">pthread_detach</span>(m_thread[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于饿汉模式直接在使用该单例之前就初始化了该静态成员变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;Singleton&gt; Singleton::m_interface = <span class="built_in">shared_ptr</span>&lt;Singleton&gt;(<span class="keyword">new</span> <span class="built_in">Singleton</span>());</span><br></pre></td></tr></table></figure>
<p>所以不需要判断是否为<code>nullptr</code>，所以也没有<strong>线程安全</strong>的问题，对于内存泄漏的问题，使用<code>shared_ptr</code>进行资源释放。</p>
<hr>
<h3 id="懒汉实现"><a href="#懒汉实现" class="headerlink" title="懒汉实现"></a>懒汉实现</h3><p>基础实现方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">有缺陷的懒汉式单例模式，会有线程安全和内存泄漏问题</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有缺陷的懒汉模式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>= (<span class="type">const</span> Singleton&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">static</span> Singleton* m_interface;</span><br><span class="line">    <span class="comment">// static shared_ptr&lt;Singleton&gt; m_interface;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Singleton</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;deconstructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">get_interface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这一步并不是线程安全的</span></span><br><span class="line">        <span class="keyword">if</span>(m_interface == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">            m_interface = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_interface;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员变量只能类内声明类外定义</span></span><br><span class="line">Singleton* Singleton::m_interface = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">worker</span><span class="params">(<span class="type">void</span>* args)</span> </span>&#123;</span><br><span class="line">    Singleton* interface = Singleton::<span class="built_in">get_interface</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> m_thread[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(m_thread+i, <span class="literal">NULL</span>, worker, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">pthread_detach</span>(m_thread[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我设置了五个线程，在回调函数里创建单例，由于对于线程竞争资源冲突现象不明显，加上了个<code>sleep(1)</code>，运行结果如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">root@iZuf6ccxsb4mprtz1c1mx2Z:~/<span class="title">Linux</span>/<span class="title">DesignPattern</span>/<span class="title">Singleton</span># ./<span class="title">Singleton_lazy_bad</span> </span></span><br><span class="line"><span class="function"><span class="title">constructor</span></span></span><br><span class="line"><span class="function"><span class="title">constructor</span></span></span><br><span class="line"><span class="function"><span class="title">constructor</span></span></span><br><span class="line"><span class="function"><span class="title">constructor</span></span></span><br><span class="line"><span class="function"><span class="title">constructor</span></span></span><br></pre></td></tr></table></figure>
<p>问题很明显，五个线程分别创建了一个单例，这是完全错误的，而且只有构造没有析构。造成了内存泄漏。</p>
<h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><p>对于线程安全问题，采用互斥锁来确保线程安全，<strong>单例模式中使用双检锁（DCL）</strong>；</p>
<blockquote>
<p><em>为什么用DCL的一些个人理解</em><br>首先使用锁的目的就是保证<code>if(m_interface == null) m_interface = new Singleton();</code>这两个语句原子化（类似），但是在创建一个单例之后<code>m_interface != nullptr</code>，就无需每次都加锁，提高性能。</p>
</blockquote>
<p>对于内存泄漏问题，使用智能指针解决。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">比较完美的懒汉式单例模式</span></span><br><span class="line"><span class="comment">使用锁解决了线程安全问题</span></span><br><span class="line"><span class="comment">使用智能指针解决内存泄漏问题</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> m_mutex;</span><br><span class="line"><span class="type">int</span> res = <span class="built_in">pthread_mutex_init</span>(&amp;m_mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>= (<span class="type">const</span> Singleton&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">// static Singleton* m_interface;</span></span><br><span class="line">    <span class="type">static</span> shared_ptr&lt;Singleton&gt; m_interface;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Singleton</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;deconstructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> shared_ptr&lt;Singleton&gt; <span class="title">get_interface</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用双检锁DCL</span></span><br><span class="line">        <span class="keyword">if</span>(m_interface == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;m_mutex);</span><br><span class="line">            <span class="keyword">if</span>(m_interface == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                m_interface = <span class="built_in">shared_ptr</span>&lt;Singleton&gt;(<span class="keyword">new</span> Singleton);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;m_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_interface;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;Singleton&gt; <span class="title">Singleton::m_interface</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">worker</span><span class="params">(<span class="type">void</span>* args)</span> </span>&#123;</span><br><span class="line">    shared_ptr&lt;Singleton&gt; interface = Singleton::<span class="built_in">get_interface</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> m_thread[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(m_thread+i, <span class="literal">NULL</span>, worker, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">pthread_detach</span>(m_thread[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下，只创建一个单例，而且成功析构。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">root@iZuf6ccxsb4mprtz1c1mx2Z:~/<span class="title">Linux</span>/<span class="title">DesignPattern</span>/<span class="title">Singleton</span># ./<span class="title">Singleton_lazy_good</span> </span></span><br><span class="line"><span class="function"><span class="title">constructor</span></span></span><br><span class="line"><span class="function"><span class="title">deconstructor</span></span></span><br></pre></td></tr></table></figure>

<p>最后还有一种基于c++11的<code>magic static</code>特性的懒汉实现，这里就不介绍了。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>图论基础</title>
    <url>/2021/09/16/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="文章对应的题目"><a href="#文章对应的题目" class="headerlink" title="文章对应的题目"></a>文章对应的题目</h3><p>797 所有可能的路径（M）</p>
<span id="more"></span>

<hr>
<p>图基本的实现方式分为<strong>邻接表</strong>和<strong>邻接矩阵</strong></p>
<ul>
<li>邻接表：把每一个节点<code>x</code>的邻居都存到一个列表里，然后把<code>x</code>和这个列表关联起来，就可以通过一个节点<code>x</code>找到其所有相邻节点。</li>
<li>邻接矩阵：是一个<code>bool</code>数组，例如<code>matrix[n][n]</code>，例如节点<code>x</code>和<code>y</code>是相连的，则<code>matrix[x][y]</code>就为<code>true</code>，若需要找x的邻居，遍历一遍<code>matrix[x]</code>即可。</li>
</ul>
<p>对于<strong>图的遍历</strong>，和多叉树类似</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(GraphNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> child : root -&gt; child) &#123;</span><br><span class="line">        <span class="built_in">traverse</span>(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是对于有环图，会陷入死循环，这时候可以添加一个<code>visited</code>数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//记录被遍历过的节点</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(graph.size())</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(GraphNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || visited[root])  <span class="keyword">return</span>;</span><br><span class="line">    visited[root] == <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> child : root -&gt; child) &#123;</span><br><span class="line">        <span class="built_in">traverse</span>(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="797-所有可能的路径"><a href="#797-所有可能的路径" class="headerlink" title="797 所有可能的路径"></a>797 所有可能的路径</h3><p>题目如下：<br><img src="https://upload-images.jianshu.io/upload_images/27610647-6de8816f86e87ace.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>解法很简单，以<code>0</code>为起点遍历图，同时记录遍历过的路径，当遍历到终点时将路径记录下来即可。而且由于是无向图，所以不需要<code>visited</code>数组。<br>代码如下（图的遍历）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">allPathsSourceTarget</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph) &#123;</span><br><span class="line">        <span class="built_in">traverse</span>(graph, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="type">int</span> size = graph.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(s == size - <span class="number">1</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : graph[s]) &#123;</span><br><span class="line">            <span class="built_in">traverse</span>(graph, i);</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://labuladong.gitee.io/algo/2/19/35/">图论基础 :: labuladong的算法小抄 (gitee.io)</a></p>
<p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          </p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>常见背包归纳</title>
    <url>/2021/11/28/%E5%B8%B8%E8%A7%81%E8%83%8C%E5%8C%85%E5%BD%92%E7%BA%B3/</url>
    <content><![CDATA[<p>基本的0-1背包、完全背包问题。</p>
<span id="more"></span>

<h1 id="一、首先对背包问题进行分类"><a href="#一、首先对背包问题进行分类" class="headerlink" title="一、首先对背包问题进行分类"></a>一、首先对背包问题进行分类</h1><ul>
<li><p>1、组合问题<br><a href="https://leetcode-cn.com/problems/combination-sum-iv/description/">377. 组合总和 Ⅳ</a><br><a href="https://leetcode-cn.com/problems/target-sum/description/">494. 目标和</a><br><a href="https://leetcode-cn.com/problems/coin-change-2/description/">518. 零钱兑换 II</a><br><strong>组合问题公式</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[i] = dp[i] + dp[i-num];</span><br></pre></td></tr></table></figure>
</li>
<li><p>2、True&#x2F;False问题<br><a href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a><br><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/description/">416. 分割等和子集</a></p>
<p><strong>True&#x2F;False问题公式</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[i] = dp[i] <span class="keyword">or</span> dp[i-num]</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">dp[i] = dp[i] | dp[i-num]</span><br></pre></td></tr></table></figure>
</li>
<li><p>3、 最大&#x2F;最小问题<br><a href="https://leetcode-cn.com/problems/ones-and-zeroes/description/">474. 一和零</a><br><a href="https://leetcode-cn.com/problems/coin-change/description/">322. 零钱兑换</a></p>
<p><strong>最大&#x2F;最小问题公式</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[i] = <span class="built_in">min</span>(dp[i], dp[i-num] + <span class="number">1</span>)</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">dp[i] = <span class="built_in">max</span>(dp[i], dp[i-num] + <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="二、背包问题技巧"><a href="#二、背包问题技巧" class="headerlink" title="二、背包问题技巧"></a>二、背包问题技巧</h1><p><strong>背包问题具备的特征</strong>：给定一个target，target可以是数字也可以是字符串，再给定一个数组nums，nums中装的可能是数字，也可能是字符串，问：能否使用nums中的元素做各种排列组合得到target。</p>
<ul>
<li>1、0-1背包<br><strong>即数组中的元素不可重复使用，nums放在外循环，target在内循环，且内循环倒序。</strong>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = target; i &gt;= nums; i--) &#123;</span><br><span class="line">        ***</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>2、完全背包<br><strong>即数组中的元素可重复使用，nums放在外循环，target在内循环。且内循环正序。</strong>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = num; i &lt;= target; i++) &#123;</span><br><span class="line">        ***</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>3、组合问题需要考虑顺序<br><strong>如果组合问题需考虑元素之间的顺序，需将target放在外循环，将nums放在内循环。</strong>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">        ***</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p>参考链接：<a href="https://leetcode-cn.com/problems/combination-sum-iv/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-wen-/">希望用一种规律搞定背包问题 - 组合总和 Ⅳ - 力扣（LeetCode） (leetcode-cn.com)</a></p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2022/03/10/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="工厂方法和抽象工厂"><a href="#工厂方法和抽象工厂" class="headerlink" title="工厂方法和抽象工厂"></a>工厂方法和抽象工厂</h2><span id="more"></span>

<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p><strong>定义一个创建对象的接口，让子类决定创建哪一个类。</strong><br><img src="https://upload-images.jianshu.io/upload_images/27610647-074107ba6bb3cf98.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Product</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Product</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">concreteProductA</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">concreteProductA</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;create concreteProductA&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">concreteProductA</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">concreteProductB</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">concreteProductB</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;create concreteProductB&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">concreteProductB</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Factory</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Factory</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Product* <span class="title">creatFactory</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">createProductA</span> : <span class="keyword">public</span> Factory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Product* <span class="title">creatFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> concreteProductA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">createProductB</span> : <span class="keyword">public</span> Factory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Product* <span class="title">creatFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> concreteProductB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Factory* fac1 = <span class="keyword">new</span> <span class="built_in">createProductA</span>();</span><br><span class="line">    Factory* fac2 = <span class="keyword">new</span> <span class="built_in">createProductB</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;**********&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Product* proA = fac1-&gt;<span class="built_in">creatFactory</span>();</span><br><span class="line">    Product* proB = fac2-&gt;<span class="built_in">creatFactory</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工厂模式实现比较简单，但是工厂模式对于对象的创建仅仅局限于一个类（即Product是一个类），若要为不同的类实现对象创建的接口，需要使用<strong>抽象工厂模式</strong></p>
<hr>
<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>结构图如下：<br><img src="https://upload-images.jianshu.io/upload_images/27610647-7616d064968cd7fc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>抽象工厂可以创建多个抽象产品类，比如说一个游戏种野怪有三种难度，共十个野怪，那么对于玩家开始游戏，就需要实例化三十个类创建野怪，这时候可以选择抽象工厂方式，将难度分为三种，解决一组相关或依赖的对象。<br>代码结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象产品A和B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ProductA</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ProductB</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">concreteProductA1</span> : <span class="keyword">public</span> ProductA&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">concreteProductA1</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;create concreteProductA1&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">concreteProductA2</span> : <span class="keyword">public</span> ProductA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">concreteProductA2</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;create concreteProductA2&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">concreteProductB1</span> : <span class="keyword">public</span> ProductB &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">concreteProductB1</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;create concreteProductB1&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">concreteProductB2</span> : <span class="keyword">public</span> ProductB &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">concreteProductB2</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;create concreteProductB2&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Factory</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Factory</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ProductA* <span class="title">creatFactoryA</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ProductB* <span class="title">creatFactoryB</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化工厂，生成类型1的产品 A1和B1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">createProduct1</span> : <span class="keyword">public</span> Factory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ProductA* <span class="title">creatFactoryA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">concreteProductA1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ProductB* <span class="title">creatFactoryB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">concreteProductB1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化工厂，生成类型2的产品 A2和B2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">createProduct2</span> : <span class="keyword">public</span> Factory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ProductA* <span class="title">creatFactoryA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">concreteProductA2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ProductB* <span class="title">creatFactoryB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">concreteProductB2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Factory* fac1 = <span class="keyword">new</span> <span class="built_in">createProduct1</span>();</span><br><span class="line">    Factory* fac2 = <span class="keyword">new</span> <span class="built_in">createProduct2</span>();</span><br><span class="line">    ProductA* A1 = fac1 -&gt; <span class="built_in">creatFactoryA</span>();</span><br><span class="line">    ProductB* B1 = fac1 -&gt; <span class="built_in">creatFactoryB</span>();</span><br><span class="line">    ProductA* A2 = fac2 -&gt; <span class="built_in">creatFactoryA</span>();</span><br><span class="line">    ProductB* B2 = fac2 -&gt; <span class="built_in">creatFactoryB</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以把A、B想象成野怪，1、2想象成难度，如果玩家选择难度2，直接使用一个工厂<code>createProduct2</code>即可。</p>
<hr>
<p><strong>注意：一定要区分工厂方法和抽象工厂！！！</strong></p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>手撕-KMP、堆排序、快排</title>
    <url>/2022/03/26/%E6%89%8B%E6%92%95-KMP%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F%E3%80%81%E5%BF%AB%E6%8E%92/</url>
    <content><![CDATA[<blockquote>
<p>经典算法手撕</p>
</blockquote>
<span id="more"></span>

<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>kmp算法的核心就是求<code>next</code>数组，即最长公共前后缀个数数组。<br>比如对于文本串<code>string s = &quot;aabaabaaf&quot;</code>，模式串<code>string t = &quot;aabaaf&quot;</code>，若要暴力检测的话，遍历到<code>s[5] != t[5]</code>，需要重新回到<code>s[1]</code>和<code>t[0]</code>重新遍历，但是若有一个数组记录最长公共前后缀的话，可以倒退到<code>s[next[5-1]+1]</code>即继续匹配<code>s[5]</code>和<code>t[2]</code>；如下图。<a href="https://www.programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html">图源：卡哥</a><br><img src="https://upload-images.jianshu.io/upload_images/27610647-445a75f6e75deb5a.gif?imageMogr2/auto-orient/strip"></p>
<p>求next数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">m_next</span><span class="params">(string&amp; str, vector&lt;<span class="type">int</span>&gt;&amp; next)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>] = j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; str[i] != str[j+<span class="number">1</span>]) &#123;</span><br><span class="line">            j = next[j];  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == str[j+<span class="number">1</span>]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求出<code>next</code>数组之后就可以进行模式匹配了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//return value : start index of s.str(T)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kmp</span><span class="params">(string &amp; str, string&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(t.size())</span></span>;</span><br><span class="line">    <span class="built_in">m_next</span>(t, next);</span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s[i] != t[j+<span class="number">1</span>]) &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == t[j+<span class="number">1</span>]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == t.<span class="built_in">size</span>()<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - t.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆分为大顶堆和小顶堆，如图所示，即根节点是最大或者最小值。<br><img src="https://upload-images.jianshu.io/upload_images/27610647-e3c284bf915c85ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>对于数组<code>vector&lt;int&gt; nums = &#123;7, 3, 9, 4, 6, 1, 5, 2, 8&#125;;</code>，若要降序输出，首先需要将该数组构造成一个小顶堆，结果为<code>9 8 7 4 6 1 5 2 3 </code>，然后交换<code>nums[0]</code>和<code>nums[nums.size()-1]</code>，继续构造小顶堆，如此循环。<br>注意：初始化构造小顶堆时，需要从第一个非叶子结点向上构造，即：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一次构造小顶堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = (nums.<span class="built_in">size</span>()/<span class="number">2</span>)<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">heapify</span>(nums, i, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造小顶堆之后继续排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//交换根节点和未排序的最后一个元素</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[i]);</span><br><span class="line">        <span class="built_in">heapify</span>(nums, <span class="number">0</span>, i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>heapify</code>的实现🌟🌟🌟🌟🌟</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> father = start;</span><br><span class="line">	<span class="type">int</span> son = <span class="number">2</span>*father + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(son &lt;= index) &#123;</span><br><span class="line">		<span class="keyword">if</span>(son &lt;= index - <span class="number">1</span> &amp;&amp; nums[son] &gt; nums[son + <span class="number">1</span>])</span><br><span class="line">			son++;</span><br><span class="line">		<span class="keyword">if</span>(nums[son] &lt; nums[father])</span><br><span class="line">			<span class="built_in">swap</span>(nums[son], nums[father]);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		father = son;</span><br><span class="line">		son = <span class="number">2</span>*father + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>C++中实现了<code>template &lt;class T, class Container = vector&lt;T&gt;,   class Compare = less&lt;typename Container::value_type&gt; &gt; class priority_queue;</code>这个STL，需要使用头文件<code>#include &lt;queue&gt;</code></p>
<p>具体用法为<code>class T</code>是保存的参数类型，<code>class Container = vector&lt;T&gt;</code>是堆中储存元素的容器，默认是<code>vector&lt;T&gt;</code>，<code>class Compare = less&lt;typename Container::value_type&gt;</code>是堆的比较函数，默认是<code>less&lt;T&gt;</code>即小顶堆，也可以使用<code>greater&lt;int&gt;</code>构造大顶堆。</p>
<p><strong>注意，优先队列队首元素为<code>que.top()</code>不是<code>que.front()</code></strong></p>
<ul>
<li><p>具体用法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; que;</span><br><span class="line">	que.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">	que.<span class="built_in">push</span>(<span class="number">8</span>);</span><br><span class="line">	que.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">	que.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line">	que.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; que.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造的是大顶堆，然后堆排序，<strong>构造出的元素为队列头部为最小值。</strong><br>输出为</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">wang@Wangs-MacBook-Pro test_cpp % ./priority_queue </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">8</span> <span class="number">9</span> %              </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>自定义比较类</strong><br>以<code>pair&lt;int, int&gt;</code>举例子，将队列中按照<code>pair.first</code>降序排列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义比较类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, cmp&gt; que;</span><br><span class="line">	que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">	que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">8</span>,<span class="number">0</span>));</span><br><span class="line">	que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">7</span>,<span class="number">0</span>));</span><br><span class="line">	que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">	que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>,<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; que.<span class="built_in">top</span>().first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">wang@Wangs-MacBook-Pro test_cpp % ./priority_queue</span><br><span class="line"><span class="number">8</span> <span class="number">7</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> %   </span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> pivotPosition = <span class="built_in">partition</span>(nums, left, right);</span><br><span class="line">	<span class="built_in">quick_sort</span>(nums, left, pivotPosition - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">quick_sort</span>(nums, pivotPosition + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="type">int</span> rand_num = left + (<span class="built_in">rand</span>()%(right-left));</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;rand_num: &quot;</span> &lt;&lt; rand_num &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">swap</span>(nums[left], nums[rand_num]);</span><br><span class="line">	<span class="type">int</span> pivot = nums[left];</span><br><span class="line">	<span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">		<span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] &gt;= pivot)</span><br><span class="line">			right--;</span><br><span class="line">		<span class="built_in">swap</span>(nums[left], nums[right]);</span><br><span class="line">		<span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] &lt;= pivot)</span><br><span class="line">			left++;</span><br><span class="line">		<span class="built_in">swap</span>(nums[left], nums[right]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">77</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">6</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">		cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">quick_sort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">		cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>手撕HashMap</title>
    <url>/2022/04/15/%E6%89%8B%E6%92%95HashMap/</url>
    <content><![CDATA[<hr>
<h2 id="HashMap不完整实现，大概意思是这样"><a href="#HashMap不完整实现，大概意思是这样" class="headerlink" title="HashMap不完整实现，大概意思是这样"></a>HashMap不完整实现，大概意思是这样</h2><span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author Bi Wang</span></span><br><span class="line"><span class="comment">* @version 创建时间：2022-3-18</span></span><br><span class="line"><span class="comment">* 说明：本程序实现了一个HashMap。</span></span><br><span class="line"><span class="comment">* 功能：使用开链法解决Hash冲突，实现了查找、插入、删除功能。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HASHMAP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASHMAP_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashNode</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Key _key;</span><br><span class="line">    Value _value;</span><br><span class="line">    HashNode* next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HashNode</span>(Key key, Value Value):_key(key), _value(value), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">HashNode</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载赋值函数</span></span><br><span class="line">    HashNode&amp; <span class="keyword">operator</span>=(<span class="type">const</span> HashNode&amp; node) &#123;</span><br><span class="line">        _key = node._key;</span><br><span class="line">        _value = node._value;</span><br><span class="line">        next = node.next;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">HashFunc</span>, <span class="keyword">class</span> <span class="title class_">EqualKey</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashMap</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _size;</span><br><span class="line">    HashFunc hash;</span><br><span class="line">    EqualKey equal;</span><br><span class="line">    HashNode&lt;Key, Value&gt; ** hash_table;</span><br><span class="line">    Value valueNUll;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HashMap</span>(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> size));</span><br><span class="line">    ~<span class="built_in">HashMap</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> Key&amp; key, <span class="type">const</span> Value&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">del</span><span class="params">(<span class="type">const</span> Key&amp; key)</span></span>;</span><br><span class="line">    <span class="function">Value&amp; <span class="title">find</span><span class="params">(<span class="type">const</span> Key&amp; key)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">HashFunc</span>, <span class="keyword">class</span> <span class="title class_">EqualKey</span>&gt;</span><br><span class="line">HashMap&lt;Key, Value, HashFunc, EqualKey&gt;::<span class="built_in">HashMap</span>(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> size) : </span><br><span class="line">_size(size), <span class="built_in">hash</span>(), <span class="built_in">equal</span>() &#123;</span><br><span class="line">    hash_table = <span class="keyword">new</span> HashNode&lt;Key, Node&gt;*[_size];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; _size; i++) &#123;</span><br><span class="line">        hash_table[i] = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">HashFunc</span>, <span class="keyword">class</span> <span class="title class_">EqualKey</span>&gt;</span><br><span class="line">HashMap&lt;Key, Value, HashFunc, EqualKey&gt;::~<span class="built_in">HashMap</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; _size; i++) &#123;</span><br><span class="line">        HashNode&lt;Key, Value&gt;* cur = hash_table[i];</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            HashNode&lt;Key, Value&gt;* temp = cur;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] hash_table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">HashFunc</span>, <span class="keyword">class</span> <span class="title class_">EqualKey</span>&gt;</span><br><span class="line"><span class="type">bool</span> HashMap&lt;Key, Value, HashFunc, EqualKey&gt;::<span class="built_in">insert</span>(<span class="type">const</span> Key&amp; key, <span class="type">const</span> Value&amp; value) &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> index = <span class="built_in">hash</span>(key)%_size;</span><br><span class="line">    HashNode&lt;Key, Value&gt;* node = <span class="keyword">new</span> <span class="built_in">HashNode</span>&lt;Key, Value&gt;(key, value);</span><br><span class="line">    node-&gt;next = hash_table[index];</span><br><span class="line">    hash_table[index] = node;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">HashFunc</span>, <span class="keyword">class</span> <span class="title class_">EqualKey</span>&gt;</span><br><span class="line"><span class="type">bool</span> HashMap&lt;Key, Value, HashFunc, EqualKey&gt;::<span class="built_in">del</span>(<span class="type">const</span> Key&amp; key) &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> index = <span class="built_in">hash</span>(key)%_size;</span><br><span class="line">    HashNode&lt;Key, Value&gt;* node = hash_table[index];</span><br><span class="line">    HashNode&lt;Key, Value&gt;* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    prev -&gt; next = node;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node -&gt; _key == key) &#123;</span><br><span class="line">            prev -&gt; next = node -&gt; next;</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node -&gt; next;</span><br><span class="line">        prev = prev -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">HashFunc</span>, <span class="keyword">class</span> <span class="title class_">EqualKey</span>&gt;</span><br><span class="line">Value&amp; HashMap&lt;Key, Value, HashFunc, EqualKey&gt;::<span class="built_in">find</span>(<span class="type">const</span> Key&amp; key) &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> index = <span class="built_in">hash</span>(key)%_size;</span><br><span class="line">    HashNode&lt;Key, Value&gt;* node = hash_table[index];</span><br><span class="line">    <span class="keyword">if</span>(!node)   <span class="keyword">return</span> valueNUll;</span><br><span class="line">    <span class="keyword">while</span>(node) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node -&gt; _key == key)</span><br><span class="line">            <span class="keyword">return</span> node -&gt; _value;</span><br><span class="line">        node = node -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希函数</span></span><br><span class="line"><span class="comment">// class HashFunc</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     int operator()(const unsigned int &amp; key )</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         int hash = 0;</span></span><br><span class="line"><span class="comment">//         for(int i = 0; i &lt; key.length(); ++i)</span></span><br><span class="line"><span class="comment">//         &#123;</span></span><br><span class="line"><span class="comment">//             hash = hash &lt;&lt; 7 ^ key[i];</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return (hash &amp; 0x7FFFFFFF);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//比较函数，上面实现的哈希表默认是数值类型，不需要比较函数</span></span><br><span class="line"><span class="comment">// class EqualKey</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     bool operator()(const string &amp; A, const string &amp; B)</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         if (A.compare(B) == 0)</span></span><br><span class="line"><span class="comment">//             return true;</span></span><br><span class="line"><span class="comment">//         else</span></span><br><span class="line"><span class="comment">//             return false;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>手撕线程池</title>
    <url>/2022/01/22/%E6%89%8B%E6%92%95%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="线程池Threadpool简单实现"><a href="#线程池Threadpool简单实现" class="headerlink" title="线程池Threadpool简单实现"></a>线程池Threadpool简单实现</h2><span id="more"></span>

<p>作为web服务器实现高并发的基本组件之一，单独用I&#x2F;O多路复用很可能会导致后续请求阻塞，但是不断创建线程和销毁线程会增加性能开销，于是采用线程池从工作队列抢占任务。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadpool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">threadpool</span>(<span class="type">int</span> thread_num = <span class="number">5</span>, <span class="type">int</span> max_request = <span class="number">10000</span>);</span><br><span class="line">	~<span class="built_in">threadpool</span>();</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">add</span><span class="params">(T* request)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">worker</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">concreateWork</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_thread_num;</span><br><span class="line">	<span class="type">int</span> m_max_requests;</span><br><span class="line">	<span class="type">pthread_t</span>* m_thread_arr;</span><br><span class="line">	queue&lt;T&gt; m_workqueue;</span><br><span class="line">	<span class="type">bool</span> m_stop;</span><br><span class="line"></span><br><span class="line">	locker m_locker;</span><br><span class="line">	sem m_stat;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">threadpool&lt;T&gt;::<span class="built_in">threadpool</span>(<span class="type">int</span> thread_num = <span class="number">5</span>, <span class="type">int</span> max_request = <span class="number">10000</span>) </span><br><span class="line">: <span class="built_in">m_thread_num</span>(thread_num), <span class="built_in">m_max_requests</span>(max_request), <span class="built_in">m_stop</span>(<span class="literal">false</span>), <span class="built_in">m_thread_arr</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">	m_thread_arr = <span class="keyword">new</span> <span class="type">pthread_t</span>[m_thread_num];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_thread_num; i++) &#123;</span><br><span class="line">		<span class="comment">//work必须为静态成员函数</span></span><br><span class="line">		<span class="built_in">pthread_create</span>(m_thread_arr + i, <span class="literal">NULL</span>, worker, <span class="keyword">this</span>)；</span><br><span class="line">		<span class="built_in">pthread_detach</span>(m_thread_arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">threadpool&lt;T&gt;::~<span class="built_in">threadpool</span>() &#123;</span><br><span class="line">	<span class="keyword">delete</span>[] m_thread_arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> threadpool&lt;T&gt;::<span class="built_in">add</span>(T* request) &#123;</span><br><span class="line">	m_locker.<span class="built_in">lock</span>();</span><br><span class="line">	<span class="keyword">if</span>(m_workqueue.<span class="built_in">size</span>() &gt; m_max_requests) &#123;</span><br><span class="line">		m_locker.<span class="built_in">unlock</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	m_workqueue.<span class="built_in">push_back</span>(request);</span><br><span class="line">	m_workqueue.<span class="built_in">unlock</span>();</span><br><span class="line">	m_stat.<span class="built_in">post</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span>* threadpool&lt;T&gt;::<span class="built_in">worker</span>(<span class="type">void</span>* arg) &#123;</span><br><span class="line">	threadpool* work = (threadpool*) arg;</span><br><span class="line">	work -&gt; <span class="built_in">concreateWork</span>();</span><br><span class="line">	<span class="keyword">return</span> work;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> threadpool&lt;T&gt;::<span class="built_in">run</span>() &#123;</span><br><span class="line">	m_stat.<span class="built_in">wait</span>();</span><br><span class="line">	m_locker.<span class="built_in">lock</span>();</span><br><span class="line">	T* cur_request = m_workqueue.<span class="built_in">front</span>();</span><br><span class="line">	m_workqueue.<span class="built_in">pop_front</span>();</span><br><span class="line">	m_locker.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">	cur_request-&gt;<span class="built_in">process</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//封装互斥锁</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">locker</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">pthread_mutex_t</span> m_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">locker</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">exception</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">locker</span>() &#123;</span><br><span class="line">		<span class="built_in">pthread_mutex_destory</span>(&amp;m_mutex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">pthread_mutex_lock</span>(&amp;m_mutex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">pthread_mutex_unlock</span>(&amp;m_mutex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//封装信号量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sem</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">sem_t</span> m_sem;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">sem</span>() &#123;</span><br><span class="line">		<span class="built_in">sem_init</span>(&amp;m_sem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sem</span>(<span class="type">int</span> num) &#123;</span><br><span class="line">		<span class="built_in">sem_init</span>(&amp;m_sem, <span class="number">0</span>, num);</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">sem</span>() &#123;</span><br><span class="line">		<span class="built_in">sem_destory</span>(&amp;m_sem);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">post</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">sem_post</span>(&amp;m_sem);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">sem_eait</span>(&amp;m_sem);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>模版方法模式</title>
    <url>/2022/03/15/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<hr>
<h4 id="模版方法（Template-Method）模式"><a href="#模版方法（Template-Method）模式" class="headerlink" title="模版方法（Template Method）模式"></a>模版方法（Template Method）模式</h4><span id="more"></span>

<p>在面向对象系统的设计中，对于某一个业务逻辑在不同的对象下实现细节不一样，但是逻辑框架相同，可以使用模版方法模式。</p>
<p>普通实现中，某一业务逻辑需要按照顺序执行<code>fun1</code>～<code>fun4</code>，其中<code>fun2</code>和<code>fun3</code>在对象A和B中实现不相同，代码逻辑如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">base</span>()&#123;&#125;;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">base</span>()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="title">fun2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="title">fun3</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun4</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">  ~<span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实现细节</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实现细节</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//业务逻辑</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">fun1</span>();</span><br><span class="line">    <span class="built_in">fun2</span>();</span><br><span class="line">    <span class="built_in">fun3</span>();</span><br><span class="line">    <span class="built_in">fun4</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>()&#123;&#125;;</span><br><span class="line">  ~<span class="built_in">B</span>()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不同的实现细节</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不同的实现细节</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//业务逻辑</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">fun1</span>();</span><br><span class="line">    <span class="built_in">fun2</span>();</span><br><span class="line">    <span class="built_in">fun3</span>();</span><br><span class="line">    <span class="built_in">fun4</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种实现方式破坏了<strong>依赖倒置原则（DIP）</strong>，即程序要依赖于抽象接口，而不是具体实现，所以高层（基类）应该提供接口用于不同的低层（子类）实现，控制权交给父类。</p>
<p>使用模版方法模式代码框架如下，有基类<code>Base</code>，负责业务逻辑框架的函数<code>void run()</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base</span>()&#123;&#125;;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Base</span>()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun3</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun4</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="comment">//业务逻辑</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">fun1</span>();</span><br><span class="line">    <span class="built_in">fun2</span>();</span><br><span class="line">    <span class="built_in">fun3</span>();</span><br><span class="line">    <span class="built_in">fun4</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">  ~<span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实现细节</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实现细节</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>()&#123;&#125;;</span><br><span class="line">  ~<span class="built_in">B</span>()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不同的实现细节</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不同的实现细节</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">//实现1</span></span><br><span class="line">  Base* obj1 = <span class="keyword">new</span> A;</span><br><span class="line">  obj1 -&gt; <span class="built_in">run</span>();</span><br><span class="line">  <span class="comment">//实现2</span></span><br><span class="line">  Base* obj2 = <span class="keyword">new</span> B;</span><br><span class="line">  obj2 -&gt; <span class="built_in">run</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里对于不同的业务实现A和B，高层都提供了两个接口（虚函数），逻辑交给了高层，利用了多态性和晚绑定。</p>
<hr>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯问题</title>
    <url>/2021/08/10/%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="文章对应的题目"><a href="#文章对应的题目" class="headerlink" title="文章对应的题目"></a>文章对应的题目</h3><p>46 全排列（M）<br>51 N皇后（H）</p>
<span id="more"></span>

<hr>
<p>解决一个回溯问题，基本上就是一个决策树的遍历过程。有三点需要考虑：</p>
<ul>
<li><strong>路径</strong>：也就是已经做出的选择。</li>
<li><strong>选择列表</strong>：当前可以做的选择（for循环）</li>
<li><strong>结束条件</strong>：已经遍历到决策树底层，返回结果。<br>代码框架：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line">def <span class="built_in">backtrack</span>(路径, 选择列表):</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.<span class="built_in">add</span>(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">        做选择（一般是把当前节点加入到路径中）</span><br><span class="line">        <span class="built_in">backtrack</span>(路径, 选择列表)</span><br><span class="line">        撤销选择（一般是从路径中剔除当前节点，直接pop）</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="46-全排列（M）"><a href="#46-全排列（M）" class="headerlink" title="46 全排列（M）"></a>46 全排列（M）</h3><p><img src="https://upload-images.jianshu.io/upload_images/27610647-9062ea46e717d84d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ul>
<li><strong>首先是第一点</strong><br>路径：在本题中，需要遍历决策树，所以路径就是节点的值、</li>
<li><strong>第二点</strong><br>选择列表：选择列表是从所有数字中剔除路径中已经存在的节点之后，剩下的所有的选项。<br>如何判断路径中已经添加过当前节点了呢？可以使用一个布尔数组<code>used</code>。</li>
<li><strong>第三点</strong><br>结束条件：<code>path.size() == nums.size()</code>路径长度和给定的数字数量相等时，即遍历到了决策树的最底层。</li>
<li><strong>第四点</strong><br>做选择和撤销选择：这个理解较简单，在往下遍历时（做选择），在路径中加入当前节点即可，但由于我们还有个<code>used</code>数组，所以还要将判断<code>used[i]</code>，并将其置为<code>true</code>.<br>撤销选择时，即回溯，需要撤销选择，将<code>path</code>中的节点<code>pop</code>出，并将<code>used[i]</code>其置为<code>false</code>。<br>代码如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt; used)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i] == <span class="literal">true</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtrack</span>(nums, used);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="51-N皇后（H）"><a href="#51-N皇后（H）" class="headerlink" title="51 N皇后（H）"></a>51 N皇后（H）</h3><p><img src="https://upload-images.jianshu.io/upload_images/27610647-d9f944251d24d1af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><em>注：皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。</em><br>首先，回溯框架中的路径即对应一个棋盘，定义为<code>vector&lt;string&gt; board(n, string(n, &#39;.&#39;))</code><br>然后遍历每一行（对应一个<code>string</code>）中的每一列，将满足条件的置为<code>&#39;Q&#39;</code>，决策树如下：<br><img src="https://upload-images.jianshu.io/upload_images/27610647-7bbcbb50182567da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">，<br>然后对于做选择和撤销选择，即将棋盘<code>board</code>中的每一个点换成<code>&#39;Q&#39;</code>和<code>&#39;.&#39;</code>，对于判断在当前位置放置皇后是否有效，可以使用一个<code>valid</code>辅助函数判断是否有效（注：皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(vector&lt;string&gt;&amp; board, <span class="type">int</span> row, <span class="type">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = board.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 检查列是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][col] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查右上方是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查左上方是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">board</span><span class="params">(n, string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">        <span class="built_in">backtrack</span>(board, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;string&gt;&amp; board, <span class="type">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == board.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(board);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> col = <span class="number">0</span>; col &lt; board.<span class="built_in">size</span>(); col ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">valid</span>(board, row, col))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            board[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            <span class="built_in">backtrack</span>(board, row + <span class="number">1</span>);</span><br><span class="line">            board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(vector&lt;string&gt;&amp; board, <span class="type">int</span> row, <span class="type">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 检查列是否有皇后互相冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][col] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查右上方是否有皇后互相冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查左上方是否有皇后互相冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>小拓展：<br>如果我们获得一个N皇后的解法就返回结果，我们只需在得到第一个结果的时候<code>return true;</code>即可，如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数找到一个答案后就返回 true</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">backtrack</span><span class="params">(vector&lt;string&gt;&amp; board, <span class="type">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (row == board.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(board);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        board[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">backtrack</span>(board, row + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以思考一下解数独。</li>
</ul>
<hr>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://labuladong.gitee.io/algo/2/19/35/">图论基础 :: labuladong的算法小抄 (gitee.io)</a></p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存淘汰策略-LRU、LFU</title>
    <url>/2022/04/06/%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5-LRU%E3%80%81LFU/</url>
    <content><![CDATA[<p>LRU和LFU简单实现</p>
<span id="more"></span>

<h4 id="1-LRU（最近最少使用缓存）"><a href="#1-LRU（最近最少使用缓存）" class="headerlink" title="1. LRU（最近最少使用缓存）"></a>1. LRU（最近最少使用缓存）</h4><blockquote>
<p>力扣146题</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> key, val;</span><br><span class="line">    Node* prev;</span><br><span class="line">    Node* next;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> x, <span class="type">int</span> y) : <span class="built_in">key</span>(x), <span class="built_in">val</span>(y), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node* head = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    Node* tail = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DoubleList</span>() &#123;</span><br><span class="line">        head -&gt; next = tail;</span><br><span class="line">        tail -&gt; prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(Node* l_node)</span> </span>&#123;</span><br><span class="line">        l_node -&gt; next = tail;</span><br><span class="line">        l_node -&gt; prev = tail -&gt; prev;</span><br><span class="line">        tail -&gt; prev -&gt; next = l_node;</span><br><span class="line">        tail -&gt; prev = l_node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Node* l_node)</span> </span>&#123;</span><br><span class="line">        l_node -&gt; prev -&gt; next = l_node -&gt; next;</span><br><span class="line">        l_node -&gt; next -&gt; prev = l_node -&gt; prev;</span><br><span class="line">        l_node -&gt; prev = <span class="literal">nullptr</span>;</span><br><span class="line">        l_node -&gt; next = <span class="literal">nullptr</span>;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head -&gt; next == tail)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        Node* First = head -&gt; next;</span><br><span class="line">        <span class="built_in">remove</span>(First);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> First;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">List_size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, Node*&gt; map;</span><br><span class="line">    DoubleList dlist;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) : <span class="built_in">capacity</span>(capacity)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = map.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(it == map.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        Node* temp = map[key];</span><br><span class="line">        dlist.<span class="built_in">remove</span>(temp);</span><br><span class="line">        dlist.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        <span class="keyword">return</span> temp -&gt; val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = map.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(it != map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            Node* temp = map[key];</span><br><span class="line">            temp -&gt; val = value;</span><br><span class="line">            dlist.<span class="built_in">remove</span>(temp);</span><br><span class="line">            dlist.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dlist.<span class="built_in">List_size</span>() == capacity) &#123;</span><br><span class="line">            Node* first = dlist.<span class="built_in">removeFirst</span>();</span><br><span class="line">            map.<span class="built_in">erase</span>(map.<span class="built_in">find</span>(first -&gt; key));</span><br><span class="line">        &#125;</span><br><span class="line">        Node* x = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">        map.<span class="built_in">emplace</span>(key, x);</span><br><span class="line">        dlist.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-LFU（最不经常使用缓存）"><a href="#2-LFU（最不经常使用缓存）" class="headerlink" title="2. LFU（最不经常使用缓存）"></a>2. LFU（最不经常使用缓存）</h4><blockquote>
<p>力扣460题</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; key2val;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; key2freq;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, list&lt;<span class="type">int</span>&gt;&gt; freq2keys;</span><br><span class="line">    <span class="type">int</span> minFreq = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increaseFreq</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> freq = key2freq[key];</span><br><span class="line">        key2freq[key]++;</span><br><span class="line">        freq2keys[freq].<span class="built_in">remove</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(freq2keys[freq].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            freq2keys.<span class="built_in">erase</span>(freq);</span><br><span class="line">            <span class="keyword">if</span>(freq == <span class="keyword">this</span>-&gt;minFreq)</span><br><span class="line">                <span class="keyword">this</span>-&gt;minFreq++;</span><br><span class="line">        &#125;</span><br><span class="line">        freq2keys[freq+<span class="number">1</span>].<span class="built_in">push_front</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeMinfreqKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> key = freq2keys[<span class="keyword">this</span>-&gt;minFreq].<span class="built_in">back</span>();</span><br><span class="line">        freq2keys[<span class="keyword">this</span>-&gt;minFreq].<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">if</span>(freq2keys[<span class="keyword">this</span>-&gt;minFreq].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            freq2keys.<span class="built_in">erase</span>(<span class="keyword">this</span>-&gt;minFreq);</span><br><span class="line">        &#125;</span><br><span class="line">        key2val.<span class="built_in">erase</span>(key);</span><br><span class="line">        key2freq.<span class="built_in">erase</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">LFU</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;&amp; operators, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> oper : operators) &#123;</span><br><span class="line">            <span class="keyword">if</span>(oper[<span class="number">0</span>] == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = key2val.<span class="built_in">find</span>(oper[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(it == key2val.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(it-&gt;second);</span><br><span class="line">                    <span class="built_in">increaseFreq</span>(oper[<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(oper[<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = key2val.<span class="built_in">find</span>(oper[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(it != key2val.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    key2val[oper[<span class="number">1</span>]] = oper[<span class="number">2</span>];</span><br><span class="line">                    <span class="built_in">increaseFreq</span>(oper[<span class="number">1</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(size == k) &#123;</span><br><span class="line">                        <span class="built_in">removeMinfreqKey</span>();</span><br><span class="line">                        size--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    key2val[oper[<span class="number">1</span>]] = oper[<span class="number">2</span>];</span><br><span class="line">                    key2freq[oper[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">                    freq2keys[<span class="number">1</span>].<span class="built_in">push_front</span>(oper[<span class="number">1</span>]);</span><br><span class="line">                    <span class="keyword">this</span>-&gt;minFreq = <span class="number">1</span>;</span><br><span class="line">                    size++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>读写锁实现</title>
    <url>/2022/05/08/%E8%AF%BB%E5%86%99%E9%94%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="使用互斥锁和条件变量实现读写锁"><a href="#使用互斥锁和条件变量实现读写锁" class="headerlink" title="使用互斥锁和条件变量实现读写锁"></a>使用互斥锁和条件变量实现读写锁</h3><span id="more"></span>

<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">rw_lock</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> stat;   <span class="comment">//0 : 无锁，-1 : 写锁， &gt;0 : 读锁的数量</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex;  </span><br><span class="line">    <span class="type">pthread_cond_t</span> cond;  </span><br><span class="line">    </span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">rw_lock</span>() : <span class="built_in">stat</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">pthread_cond_init</span>(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">rw_lock</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rdlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span> (stat &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        ++stat;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rwunlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        --stat;</span><br><span class="line">        <span class="keyword">if</span> (stat == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">pthread_cond_signal</span>(&amp;cond);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wrlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span> (stat &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        --stat;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wrunlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        ++stat;</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;cond);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>The workqueue of Linux kernel</title>
    <url>/2025/08/03/The-workqueue-of-Linux-kernel/</url>
    <content><![CDATA[<blockquote>
<p>Introduction for the workqueue of Linux kernel</p>
</blockquote>
<span id="more"></span>

<h2 id="1-BG"><a href="#1-BG" class="headerlink" title="1. BG"></a>1. BG</h2><p>workqueue主要是提供一个小型的、方便创建的异步工作环境，user无需创建内核线程便可实现异步效果。相应的，workqueue也是defer interrupt的一种常用方式。</p>
<p>在Kernel最初的workqueue实现中，多线程wq在每个CPU上有一个工作者线程，而单线程 wq在全系统有一个工作者线程。一个MT wq需要保持与CPU数量相同的工 作者数量。这些年来，内核增加了很多MT wq的用户，随着CPU核心数量的不断 增加，一些系统刚启动就达到了默认的32k PID的饱和空间。当前Kernel采用的是并发管理工作队列（<strong>Concurrency Managed Workqueue,</strong> CMWQ），下面是CMWQ的几个元素：</p>
<ul>
<li>work ：工作。</li>
<li>workqueue ：工作的集合。workqueue 和 work 是一对多的关系。</li>
<li>worker ：工人。在代码中 worker 对应一个 <code>work_thread()</code> 内核线程。</li>
<li>worker_pool：工人的集合。worker_pool 和 worker 是一对多的关系。</li>
<li>pwq(pool_workqueue)：中间人 &#x2F; 中介，负责建立起 workqueue 和 worker_pool 之间的关系。workqueue 和 pwq 是一对多的关系，pwq 和 worker_pool 是一对一的关系。</li>
</ul>
<p>下面根据源码具体分析各个元素：</p>
<h2 id="2-worker-pool"><a href="#2-worker-pool" class="headerlink" title="2. worker_pool"></a>2. worker_pool</h2><p>执行work的具体action的线程为worker，worker的一组集合即为worker_pool。CMWQ即根据当前work的负载来动态增减（管理）worker_pool中worker的数量。CMWQ 对 worker_pool 分成两类：</p>
<ol>
<li>normal worker_pool，给通用的 workqueue 使用；</li>
<li>unbound worker_pool，给 WQ_UNBOUND 类型的的 workqueue 使用；</li>
</ol>
<p>workqueue子系统模块的init是三段式的：<code>workqueue_init_early</code>、<code>workqueue_init</code>及<code>workqueue_init_topology</code>。本文按照各个元素来剖析workqueue，并不会关注workqueue子系统的加载流程。</p>
<h3 id="2-1-normal-worker-pool"><a href="#2-1-normal-worker-pool" class="headerlink" title="2.1 normal worker pool"></a>2.1 normal worker pool</h3><ol>
<li><code>workqueue_init_early</code>→<code>init_worker_pool</code></li>
<li><code>workqueue_init</code>→<code>create_worker</code></li>
</ol>
<p><code>workqueue_init_early</code>函数会调用<code>init_worker_pool</code>来为每个cpu创建两个<code>worker_pool</code>，nice值分别为<code>0</code>和<code>HIGHPRI_NICE_LEVEL</code></p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/workqueue.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * workqueue_init_early - early init for workqueue subsystem</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is the first step of three-staged workqueue subsystem initialization and</span></span><br><span class="line"><span class="comment"> * invoked as soon as the bare basics - memory allocation, cpumasks and idr are</span></span><br><span class="line"><span class="comment"> * up. It sets up all the data structures and system workqueues and allows early</span></span><br><span class="line"><span class="comment"> * boot code to create workqueues and queue/cancel work items. Actual work item</span></span><br><span class="line"><span class="comment"> * execution starts only after kthreads can be created and scheduled right</span></span><br><span class="line"><span class="comment"> * before early initcalls.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">workqueue_init_early</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wq_pod_type</span> *<span class="title">pt</span> =</span> &amp;wq_pod_types[WQ_AFFN_SYSTEM];</span><br><span class="line">	<span class="type">int</span> std_nice[NR_STD_WORKER_POOLS] = &#123; <span class="number">0</span>, HIGHPRI_NICE_LEVEL &#125;;</span><br><span class="line">	<span class="type">int</span> i, cpu;</span><br><span class="line">  ...</span><br><span class="line">	<span class="comment">/* initialize CPU pools */</span></span><br><span class="line">	for_each_possible_cpu(cpu) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line"></span><br><span class="line">		i = <span class="number">0</span>;</span><br><span class="line">		for_each_cpu_worker_pool(pool, cpu) &#123;</span><br><span class="line">		<span class="comment">// 创建worker_pool，指定优先级（0和HIGHPRI_NICE_LEVEL）</span></span><br><span class="line">			BUG_ON(init_worker_pool(pool));</span><br><span class="line">			pool-&gt;cpu = cpu;</span><br><span class="line">			cpumask_copy(pool-&gt;attrs-&gt;cpumask, cpumask_of(cpu));</span><br><span class="line">			cpumask_copy(pool-&gt;attrs-&gt;__pod_cpumask, cpumask_of(cpu));</span><br><span class="line">			pool-&gt;attrs-&gt;nice = std_nice[i++];</span><br><span class="line">			pool-&gt;attrs-&gt;affn_strict = <span class="literal">true</span>;</span><br><span class="line">			pool-&gt;node = cpu_to_node(cpu);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* alloc pool ID */</span></span><br><span class="line">			mutex_lock(&amp;wq_pool_mutex);</span><br><span class="line">			BUG_ON(worker_pool_assign_id(pool));</span><br><span class="line">			mutex_unlock(&amp;wq_pool_mutex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>init_worker_pool</code> 是创建worker_pool的具体实现，比如初始化<code>work_list</code>和<code>idle_list</code>，创建<code>idle_worker</code>超时销毁的timer等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * init_worker_pool - initialize a newly zalloc&#x27;d worker_pool</span></span><br><span class="line"><span class="comment"> * @pool: worker_pool to initialize</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Initialize a newly zalloc&#x27;d @pool.  It also allocates @pool-&gt;attrs.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: 0 on success, -errno on failure.  Even on failure, all fields</span></span><br><span class="line"><span class="comment"> * inside @pool proper are initialized and put_unbound_pool() can be called</span></span><br><span class="line"><span class="comment"> * on @pool safely to release it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">init_worker_pool</span><span class="params">(<span class="keyword">struct</span> worker_pool *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">	raw_spin_lock_init(&amp;pool-&gt;lock);</span><br><span class="line">	pool-&gt;id = <span class="number">-1</span>;</span><br><span class="line">	pool-&gt;cpu = <span class="number">-1</span>;</span><br><span class="line">	pool-&gt;node = NUMA_NO_NODE;</span><br><span class="line">	pool-&gt;flags |= POOL_DISASSOCIATED;</span><br><span class="line">	pool-&gt;watchdog_ts = jiffies;</span><br><span class="line">	<span class="comment">// 各个workqueue将work挂载至该list上，running状态的worker执行</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;pool-&gt;worklist);</span><br><span class="line">	<span class="comment">// worker在完成一个work后，状态变为idle，添加至该list中</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;pool-&gt;idle_list);</span><br><span class="line">	hash_init(pool-&gt;busy_hash);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建超时destroy idle worker的timer</span></span><br><span class="line">	timer_setup(&amp;pool-&gt;idle_timer, idle_worker_timeout, TIMER_DEFERRABLE);</span><br><span class="line">	INIT_WORK(&amp;pool-&gt;idle_cull_work, idle_cull_fn);</span><br><span class="line"></span><br><span class="line">	timer_setup(&amp;pool-&gt;mayday_timer, pool_mayday_timeout, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;pool-&gt;workers);</span><br><span class="line">	INIT_LIST_HEAD(&amp;pool-&gt;dying_workers);</span><br><span class="line"></span><br><span class="line">	ida_init(&amp;pool-&gt;worker_ida);</span><br><span class="line">	INIT_HLIST_NODE(&amp;pool-&gt;hash_node);</span><br><span class="line">	pool-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* shouldn&#x27;t fail above this point */</span></span><br><span class="line">	pool-&gt;attrs = alloc_workqueue_attrs();</span><br><span class="line">	<span class="keyword">if</span> (!pool-&gt;attrs)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	wqattrs_clear_for_pool(pool-&gt;attrs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>workqueue init第二阶段会为每个worker_pool创建一个初始worker</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">workqueue_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line">	<span class="type">int</span> cpu, bkt;</span><br><span class="line"></span><br><span class="line">	wq_cpu_intensive_thresh_init();</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Per-cpu pools created earlier could be missing node hint. Fix them</span></span><br><span class="line"><span class="comment">	 * up. Also, create a rescuer for workqueues that requested it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	for_each_possible_cpu(cpu) &#123;</span><br><span class="line">		for_each_cpu_worker_pool(pool, cpu) &#123;</span><br><span class="line">			pool-&gt;node = cpu_to_node(cpu);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	list_for_each_entry(wq, &amp;workqueues, <span class="built_in">list</span>) &#123;</span><br><span class="line">		WARN(init_rescuer(wq),</span><br><span class="line">		     <span class="string">&quot;workqueue: failed to create early rescuer for %s&quot;</span>,</span><br><span class="line">		     wq-&gt;name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create the initial workers */</span></span><br><span class="line">	for_each_online_cpu(cpu) &#123;</span><br><span class="line">		for_each_cpu_worker_pool(pool, cpu) &#123;</span><br><span class="line">			pool-&gt;flags &amp;= ~POOL_DISASSOCIATED;</span><br><span class="line">			BUG_ON(!create_worker(pool));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hash_for_each(unbound_pool_hash, bkt, pool, hash_node)</span><br><span class="line">		BUG_ON(!create_worker(pool));</span><br><span class="line"></span><br><span class="line">	wq_online = <span class="literal">true</span>;</span><br><span class="line">	wq_watchdog_init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|-&gt;</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> worker *<span class="title function_">create_worker</span><span class="params">(<span class="keyword">struct</span> worker_pool *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span>;</span></span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="type">char</span> id_buf[<span class="number">23</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ID is needed to determine kthread name */</span></span><br><span class="line">	id = ida_alloc(&amp;pool-&gt;worker_ida, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		pr_err_once(<span class="string">&quot;workqueue: Failed to allocate a worker ID: %pe\n&quot;</span>,</span><br><span class="line">			    ERR_PTR(id));</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	worker = alloc_worker(pool-&gt;node);</span><br><span class="line">	<span class="keyword">if</span> (!worker) &#123;</span><br><span class="line">		pr_err_once(<span class="string">&quot;workqueue: Failed to allocate a worker\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	worker-&gt;id = id;</span><br><span class="line">	<span class="comment">// normal和unbound worker内核线程名创建</span></span><br><span class="line">	<span class="keyword">if</span> (pool-&gt;cpu &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">snprintf</span>(id_buf, <span class="keyword">sizeof</span>(id_buf), <span class="string">&quot;%d:%d%s&quot;</span>, pool-&gt;cpu, id,</span><br><span class="line">			 pool-&gt;attrs-&gt;nice &lt; <span class="number">0</span>  ? <span class="string">&quot;H&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">snprintf</span>(id_buf, <span class="keyword">sizeof</span>(id_buf), <span class="string">&quot;u%d:%d&quot;</span>, pool-&gt;id, id);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在指定NUMA node上创建线程，线程函数为worker_thread</span></span><br><span class="line">	worker-&gt;task = kthread_create_on_node(worker_thread, worker, pool-&gt;node,</span><br><span class="line">					      <span class="string">&quot;kworker/%s&quot;</span>, id_buf);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(worker-&gt;task)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (PTR_ERR(worker-&gt;task) == -EINTR) &#123;</span><br><span class="line">			pr_err(<span class="string">&quot;workqueue: Interrupted when creating a worker thread \&quot;kworker/%s\&quot;\n&quot;</span>,</span><br><span class="line">			       id_buf);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			pr_err_once(<span class="string">&quot;workqueue: Failed to create a worker thread: %pe&quot;</span>,</span><br><span class="line">				    worker-&gt;task);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指定nice值</span></span><br><span class="line">	set_user_nice(worker-&gt;task, pool-&gt;attrs-&gt;nice);</span><br><span class="line">	trace_android_rvh_create_worker(worker-&gt;task, pool-&gt;attrs);</span><br><span class="line">	kthread_bind_mask(worker-&gt;task, pool_allowed_cpus(pool));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* successful, attach the worker to the pool attach到worker_pool中 */</span></span><br><span class="line">	worker_attach_to_pool(worker, pool);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* start the newly created worker */</span></span><br><span class="line">	raw_spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	worker-&gt;pool-&gt;nr_workers++;</span><br><span class="line">	worker_enter_idle(worker);</span><br><span class="line">	kick_pool(pool);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * @worker is waiting on a completion in kthread() and will trigger hung</span></span><br><span class="line"><span class="comment">	 * check if not woken up soon. As kick_pool() might not have waken it</span></span><br><span class="line"><span class="comment">	 * up, wake it up explicitly once more.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	wake_up_process(worker-&gt;task);</span><br><span class="line"></span><br><span class="line">	raw_spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> worker;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">	ida_free(&amp;pool-&gt;worker_ida, id);</span><br><span class="line">	kfree(worker);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-unbounded-worker-pool"><a href="#2-2-unbounded-worker-pool" class="headerlink" title="2.2 unbounded worker pool"></a>2.2 unbounded worker pool</h3><p>normal worker pool中的worker是与cpu绑定的，Android Linux kernel大部分使用的还是unbound worker pool，schedule_work()、queue_work()函数底层均使用的是unbound。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">queue_work</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> queue_work_on(WORK_CPU_UNBOUND, wq, work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unbound worker_pool 相对应的意思，就是 worker 可以在多个 CPU 上调度的。但是他其实也是绑定的，只不过它绑定的单位不是 CPU 而是 node。所谓的 node 是对 NUMA(Non Uniform Memory Access Architecture) 系统来说的，NUMA 可能存在多个 node，每个 node 可能包含一个或者多个 CPU。</p>
<p>unbound worker pool可分为两类：</p>
<ul>
<li>unbound_std_wq_attrs</li>
<li>ordered_wq_attrs</li>
</ul>
<p>依旧在第一阶段初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">workqueue_init_early</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	<span class="comment">/* create default unbound and ordered wq attrs */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_STD_WORKER_POOLS; i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_attrs</span> *<span class="title">attrs</span>;</span></span><br><span class="line"></span><br><span class="line">		BUG_ON(!(attrs = alloc_workqueue_attrs()));</span><br><span class="line">		attrs-&gt;nice = std_nice[i];</span><br><span class="line">		unbound_std_wq_attrs[i] = attrs;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * An ordered wq should have only one pwq as ordering is</span></span><br><span class="line"><span class="comment">		 * guaranteed by max_active which is enforced by pwqs.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		BUG_ON(!(attrs = alloc_workqueue_attrs()));</span><br><span class="line">		attrs-&gt;nice = std_nice[i];</span><br><span class="line">		attrs-&gt;ordered = <span class="literal">true</span>;</span><br><span class="line">		ordered_wq_attrs[i] = attrs;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剩下的流程没太关注。</p>
<h2 id="3-worker"><a href="#3-worker" class="headerlink" title="3. worker"></a>3. worker</h2><p>worker即上文中<code>create_worker</code>函数创建的内核线程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">worker-&gt;task = kthread_create_on_node(worker_thread, worker, pool-&gt;node,</span><br><span class="line">				      <span class="string">&quot;kworker/%s&quot;</span>, id_buf);</span><br></pre></td></tr></table></figure>

<p>这里分析worker_thread是怎么执行（处理work），以及CMWQ是怎么管理worker的。</p>
<h3 id="3-1-worker-thread"><a href="#3-1-worker-thread" class="headerlink" title="3.1 worker_thread"></a>3.1 worker_thread</h3><ol>
<li>判断<code>worker-&gt;flags</code>是否已经被置为<code>WORKER_DIE</code> ，然后做detach和free操作（<code>WORKER_DIE</code> 是在由timer做的）；</li>
<li><code>worker_leave_idle</code> 离开IDLE状态</li>
<li><code>need_more_worker</code> 判断当前<code>worker_pool</code>上的work_list是否非空 &amp; <code>worker_pool</code>的running task为空；两个条件同时满足，则需要更多worker，否则继续sleep；</li>
<li>随后循环check自身是否需要转为manager（即running），然后assign work到该worker</li>
<li><code>process_one_work()</code> 该函数过长<ol>
<li>将该work置为busy</li>
<li>判断是不是cpu密集型work（<code>WQ_CPU_INTENSIVE</code>）；若是，则不能参与CMWQ，且使其成为一个独立的内核线程，并重新判断需不需要more worker（<code>kick_pool(pool);</code>）</li>
<li>执行work的具体函数（<code>worker-&gt;current_func(work);</code>）</li>
</ol>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">worker_thread</span><span class="params">(<span class="type">void</span> *__worker)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> =</span> __worker;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> =</span> worker-&gt;pool;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* tell the scheduler that this is a workqueue worker */</span></span><br><span class="line">	set_pf_worker(<span class="literal">true</span>);</span><br><span class="line">woke_up:</span><br><span class="line">	raw_spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* am I supposed to die? */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(worker-&gt;flags &amp; WORKER_DIE)) &#123;</span><br><span class="line">		raw_spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">		set_pf_worker(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">		set_task_comm(worker-&gt;task, <span class="string">&quot;kworker/dying&quot;</span>);</span><br><span class="line">		ida_free(&amp;pool-&gt;worker_ida, worker-&gt;id);</span><br><span class="line">		worker_detach_from_pool(worker);</span><br><span class="line">		WARN_ON_ONCE(!list_empty(&amp;worker-&gt;entry));</span><br><span class="line">		kfree(worker);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	worker_leave_idle(worker);</span><br><span class="line">recheck:</span><br><span class="line">	<span class="comment">/* no more worker necessary? */</span></span><br><span class="line">	<span class="keyword">if</span> (!need_more_worker(pool))</span><br><span class="line">		<span class="keyword">goto</span> sleep;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* do we need to manage? */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!may_start_working(pool)) &amp;&amp; manage_workers(worker))</span><br><span class="line">		<span class="keyword">goto</span> recheck;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * -&gt;scheduled list can only be filled while a worker is</span></span><br><span class="line"><span class="comment">	 * preparing to process a work or actually processing it.</span></span><br><span class="line"><span class="comment">	 * Make sure nobody diddled with it while I was sleeping.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WARN_ON_ONCE(!list_empty(&amp;worker-&gt;scheduled));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Finish PREP stage.  We&#x27;re guaranteed to have at least one idle</span></span><br><span class="line"><span class="comment">	 * worker or that someone else has already assumed the manager</span></span><br><span class="line"><span class="comment">	 * role.  This is where @worker starts participating in concurrency</span></span><br><span class="line"><span class="comment">	 * management if applicable and concurrency management is restored</span></span><br><span class="line"><span class="comment">	 * after being rebound.  See rebind_workers() for details.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	worker_clr_flags(worker, WORKER_PREP | WORKER_REBOUND);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span> =</span></span><br><span class="line">			list_first_entry(&amp;pool-&gt;worklist,</span><br><span class="line">					 <span class="keyword">struct</span> work_struct, entry);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (assign_work(work, worker, <span class="literal">NULL</span>))</span><br><span class="line">			process_scheduled_works(worker);</span><br><span class="line">	&#125; <span class="keyword">while</span> (keep_working(pool));</span><br><span class="line"></span><br><span class="line">	worker_set_flags(worker, WORKER_PREP);</span><br><span class="line">sleep:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * pool-&gt;lock is held and there&#x27;s no work to process and no need to</span></span><br><span class="line"><span class="comment">	 * manage, sleep.  Workers are woken up only while holding</span></span><br><span class="line"><span class="comment">	 * pool-&gt;lock or from local cpu, so setting the current state</span></span><br><span class="line"><span class="comment">	 * before releasing pool-&gt;lock is enough to prevent losing any</span></span><br><span class="line"><span class="comment">	 * event.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	worker_enter_idle(worker);</span><br><span class="line">	__set_current_state(TASK_IDLE);</span><br><span class="line">	raw_spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">	schedule();</span><br><span class="line">	<span class="keyword">goto</span> woke_up;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|-&gt;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">process_scheduled_works</span><span class="params">(<span class="keyword">struct</span> worker *worker)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span>;</span></span><br><span class="line">	<span class="type">bool</span> first = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((work = list_first_entry_or_null(&amp;worker-&gt;scheduled,</span><br><span class="line">						<span class="keyword">struct</span> work_struct, entry))) &#123;</span><br><span class="line">		<span class="keyword">if</span> (first) &#123;</span><br><span class="line">			worker-&gt;pool-&gt;watchdog_ts = jiffies;</span><br><span class="line">			first = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		process_one_work(worker, work);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">||-&gt;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">process_one_work</span><span class="params">(<span class="keyword">struct</span> worker *worker, <span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">__<span class="title function_">releases</span><span class="params">(&amp;pool-&gt;lock)</span></span><br><span class="line">__<span class="title function_">acquires</span><span class="params">(&amp;pool-&gt;lock)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span> =</span> get_work_pwq(work);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> =</span> worker-&gt;pool;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> work_data;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * It is permissible to free the struct work_struct from</span></span><br><span class="line"><span class="comment">	 * inside the function that is called from it, this we need to</span></span><br><span class="line"><span class="comment">	 * take into account for lockdep too.  To avoid bogus &quot;held</span></span><br><span class="line"><span class="comment">	 * lock freed&quot; warnings as well as problems when looking into</span></span><br><span class="line"><span class="comment">	 * work-&gt;lockdep_map, make a copy and use that here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"></span><br><span class="line">	lockdep_copy_map(&amp;lockdep_map, &amp;work-&gt;lockdep_map);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* ensure we&#x27;re on the correct CPU */</span></span><br><span class="line">	WARN_ON_ONCE(!(pool-&gt;flags &amp; POOL_DISASSOCIATED) &amp;&amp;</span><br><span class="line">		     raw_smp_processor_id() != pool-&gt;cpu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* claim and dequeue */</span></span><br><span class="line">	debug_work_deactivate(work);</span><br><span class="line">	hash_add(pool-&gt;busy_hash, &amp;worker-&gt;hentry, (<span class="type">unsigned</span> <span class="type">long</span>)work);</span><br><span class="line">	worker-&gt;current_work = work;</span><br><span class="line">	worker-&gt;current_func = work-&gt;func;</span><br><span class="line">	worker-&gt;current_pwq = pwq;</span><br><span class="line">	worker-&gt;current_at = worker-&gt;task-&gt;se.sum_exec_runtime;</span><br><span class="line">	work_data = *work_data_bits(work);</span><br><span class="line">	worker-&gt;current_color = get_work_color(work_data);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Record wq name for cmdline and debug reporting, may get</span></span><br><span class="line"><span class="comment">	 * overridden through set_worker_desc().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	strscpy(worker-&gt;desc, pwq-&gt;wq-&gt;name, WORKER_DESC_LEN);</span><br><span class="line"></span><br><span class="line">	list_del_init(&amp;work-&gt;entry);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * CPU intensive works don&#x27;t participate in concurrency management.</span></span><br><span class="line"><span class="comment">	 * They&#x27;re the scheduler&#x27;s responsibility.  This takes @worker out</span></span><br><span class="line"><span class="comment">	 * of concurrency management and the next code block will chain</span></span><br><span class="line"><span class="comment">	 * execution of the pending work items.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(pwq-&gt;wq-&gt;flags &amp; WQ_CPU_INTENSIVE))</span><br><span class="line">		worker_set_flags(worker, WORKER_CPU_INTENSIVE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Kick @pool if necessary. It&#x27;s always noop for per-cpu worker pools</span></span><br><span class="line"><span class="comment">	 * since nr_running would always be &gt;= 1 at this point. This is used to</span></span><br><span class="line"><span class="comment">	 * chain execution of the pending work items for WORKER_NOT_RUNNING</span></span><br><span class="line"><span class="comment">	 * workers such as the UNBOUND and CPU_INTENSIVE ones.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	kick_pool(pool);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Record the last pool and clear PENDING which should be the last</span></span><br><span class="line"><span class="comment">	 * update to @work.  Also, do this inside @pool-&gt;lock so that</span></span><br><span class="line"><span class="comment">	 * PENDING and queued state changes happen together while IRQ is</span></span><br><span class="line"><span class="comment">	 * disabled.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	set_work_pool_and_clear_pending(work, pool-&gt;id);</span><br><span class="line"></span><br><span class="line">	pwq-&gt;stats[PWQ_STAT_STARTED]++;</span><br><span class="line">	raw_spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	lock_map_acquire(&amp;pwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line">	lock_map_acquire(&amp;lockdep_map);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Strictly speaking we should mark the invariant state without holding</span></span><br><span class="line"><span class="comment">	 * any locks, that is, before these two lock_map_acquire()&#x27;s.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * However, that would result in:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *   A(W1)</span></span><br><span class="line"><span class="comment">	 *   WFC(C)</span></span><br><span class="line"><span class="comment">	 *		A(W1)</span></span><br><span class="line"><span class="comment">	 *		C(C)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Which would create W1-&gt;C-&gt;W1 dependencies, even though there is no</span></span><br><span class="line"><span class="comment">	 * actual deadlock possible. There are two solutions, using a</span></span><br><span class="line"><span class="comment">	 * read-recursive acquire on the work(queue) &#x27;locks&#x27;, but this will then</span></span><br><span class="line"><span class="comment">	 * hit the lockdep limitation on recursive locks, or simply discard</span></span><br><span class="line"><span class="comment">	 * these locks.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * AFAICT there is no possible deadlock scenario between the</span></span><br><span class="line"><span class="comment">	 * flush_work() and complete() primitives (except for single-threaded</span></span><br><span class="line"><span class="comment">	 * workqueues), so hiding them isn&#x27;t a problem.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	lockdep_invariant_state(<span class="literal">true</span>);</span><br><span class="line">	trace_workqueue_execute_start(work);</span><br><span class="line">	worker-&gt;current_func(work);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * While we must be careful to not use &quot;work&quot; after this, the trace</span></span><br><span class="line"><span class="comment">	 * point will only record its address.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	trace_workqueue_execute_end(work, worker-&gt;current_func);</span><br><span class="line">	pwq-&gt;stats[PWQ_STAT_COMPLETED]++;</span><br><span class="line">	lock_map_release(&amp;lockdep_map);</span><br><span class="line">	lock_map_release(&amp;pwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(in_atomic() || lockdep_depth(current) &gt; <span class="number">0</span> ||</span><br><span class="line">		     rcu_preempt_depth() &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;BUG: workqueue leaked lock or atomic: %s/0x%08x/%d/%d\n&quot;</span></span><br><span class="line">		       <span class="string">&quot;     last function: %ps\n&quot;</span>,</span><br><span class="line">		       current-&gt;comm, preempt_count(), rcu_preempt_depth(),</span><br><span class="line">		       task_pid_nr(current), worker-&gt;current_func);</span><br><span class="line">		debug_show_held_locks(current);</span><br><span class="line">		dump_stack();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The following prevents a kworker from hogging CPU on !PREEMPTION</span></span><br><span class="line"><span class="comment">	 * kernels, where a requeueing work item waiting for something to</span></span><br><span class="line"><span class="comment">	 * happen could deadlock with stop_machine as such work item could</span></span><br><span class="line"><span class="comment">	 * indefinitely requeue itself while all other CPUs are trapped in</span></span><br><span class="line"><span class="comment">	 * stop_machine. At the same time, report a quiescent RCU state so</span></span><br><span class="line"><span class="comment">	 * the same condition doesn&#x27;t freeze RCU.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cond_resched();</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * In addition to %WQ_CPU_INTENSIVE, @worker may also have been marked</span></span><br><span class="line"><span class="comment">	 * CPU intensive by wq_worker_tick() if @work hogged CPU longer than</span></span><br><span class="line"><span class="comment">	 * wq_cpu_intensive_thresh_us. Clear it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	worker_clr_flags(worker, WORKER_CPU_INTENSIVE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* tag the worker for identification in schedule() */</span></span><br><span class="line">	worker-&gt;last_func = worker-&gt;current_func;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we&#x27;re done with it, release */</span></span><br><span class="line">	hash_del(&amp;worker-&gt;hentry);</span><br><span class="line">	worker-&gt;current_work = <span class="literal">NULL</span>;</span><br><span class="line">	worker-&gt;current_func = <span class="literal">NULL</span>;</span><br><span class="line">	worker-&gt;current_pwq = <span class="literal">NULL</span>;</span><br><span class="line">	worker-&gt;current_color = INT_MAX;</span><br><span class="line">	pwq_dec_nr_in_flight(pwq, work_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-2-CMWQ"><a href="#3-2-CMWQ" class="headerlink" title="3.2 CMWQ"></a>3.2 CMWQ</h3><p>CMWQ的主要思想如下：</p>
<ul>
<li>worker_pool 中的 worker 有 3 种状态：idle、running、suspend；</li>
<li>如果 worker_pool 中有 work 需要处理，保持至少一个 running worker 来处理；</li>
<li>running worker 在处理 work 的过程中进入了阻塞 suspend 状态，为了保持其他 work 的执行，需要唤醒新的 idle worker 来处理 work；</li>
<li>如果有 work 需要执行且 running worker 大于 1 个，会让多余的 running worker 进入 idle 状态；</li>
<li>如果没有 work 需要执行，会让所有 worker 进入 idle 状态；</li>
<li>如果创建的 worker 过多，destroy_worker 在 300s(IDLE_WORKER_TIMEOUT) 时间内没有再次运行的 idle worker。</li>
</ul>
<p><img src="/2025/08/03/The-workqueue-of-Linux-kernel/cmwq.png" alt="cmwq_status"></p>
<h2 id="4-workqueue"><a href="#4-workqueue" class="headerlink" title="4 workqueue"></a>4 workqueue</h2><p>workqueue 就是存放一组 work 的集合，基本可以分为两类：一类系统创建的 workqueue，一类是用户自己创建的 workqueue。</p>
<p><strong>系统创建的wq如下：</strong></p>
<p>大致可以分为三类：</p>
<ol>
<li>普通的</li>
<li>高优先级的</li>
<li>unbound的</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">workqueue_init_early</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	system_wq = alloc_workqueue(<span class="string">&quot;events&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	system_highpri_wq = alloc_workqueue(<span class="string">&quot;events_highpri&quot;</span>, WQ_HIGHPRI, <span class="number">0</span>);</span><br><span class="line">	system_long_wq = alloc_workqueue(<span class="string">&quot;events_long&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	system_unbound_wq = alloc_workqueue(<span class="string">&quot;events_unbound&quot;</span>, WQ_UNBOUND,</span><br><span class="line">					    WQ_MAX_ACTIVE);</span><br><span class="line">	system_freezable_wq = alloc_workqueue(<span class="string">&quot;events_freezable&quot;</span>,</span><br><span class="line">					      WQ_FREEZABLE, <span class="number">0</span>);</span><br><span class="line">	system_power_efficient_wq = alloc_workqueue(<span class="string">&quot;events_power_efficient&quot;</span>,</span><br><span class="line">					      WQ_POWER_EFFICIENT, <span class="number">0</span>);</span><br><span class="line">	system_freezable_power_efficient_wq = alloc_workqueue(<span class="string">&quot;events_freezable_power_efficient&quot;</span>,</span><br><span class="line">					      WQ_FREEZABLE | WQ_POWER_EFFICIENT,</span><br><span class="line">					      <span class="number">0</span>);</span><br><span class="line">	BUG_ON(!system_wq || !system_highpri_wq || !system_long_wq ||</span><br><span class="line">	       !system_unbound_wq || !system_freezable_wq ||</span><br><span class="line">	       !system_power_efficient_wq ||</span><br><span class="line">	       !system_freezable_power_efficient_wq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建workqueue的接口为<code>alloc_workqueue</code></strong> </p>
<p>这里需要注意pool_workqueues；一个系统至少存在几十个 workqueues，“插入”一个 workqueue 的 work 可能在不同的 CPU 上运行（一般执行一个 work 的 CPU 都是将该 work 插入 wq 的线程所在的 CPU），而一个 CPU 的两个 worker pool 里处理的 work 也可能来自不同的 workqueue。</p>
<p>workqueue 和 CPU 实际形成了一种“<strong>多对多</strong>”的关系，为此创建了一个名为***”pool_workqueue*”** 的结构体（简称 pwq）来连接这两者（可理解为一个 workqueue 在一个 CPU 上的代理，如果有 50 个 workqueues，4 个CPU，那么就有 200 个 pwq）：</p>
<p><img src="/2025/08/03/The-workqueue-of-Linux-kernel/wq_struct.png" alt="wq_struct"></p>
<p>一个<code>workqueue_struct</code>中会维护与cpu个数相同的pwqs，具体的函数为<code>alloc_and_link_pwqs</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">alloc_and_link_pwqs</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> highpri = wq-&gt;flags &amp; WQ_HIGHPRI;</span><br><span class="line">	<span class="type">int</span> cpu, ret;</span><br><span class="line">	<span class="type">bool</span> skip = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	wq-&gt;cpu_pwq = alloc_percpu(<span class="keyword">struct</span> pool_workqueue *);</span><br><span class="line">	<span class="keyword">if</span> (!wq-&gt;cpu_pwq)</span><br><span class="line">		<span class="keyword">goto</span> enomem;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为每个cpu创建pwqs，并于workqueue建立联系（init_wq）</span></span><br><span class="line">	<span class="keyword">if</span> (!(wq-&gt;flags &amp; WQ_UNBOUND)) &#123;</span><br><span class="line">		for_each_possible_cpu(cpu) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> **<span class="title">pwq_p</span> =</span></span><br><span class="line">				per_cpu_ptr(wq-&gt;cpu_pwq, cpu);</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> =</span></span><br><span class="line">				&amp;(per_cpu_ptr(cpu_worker_pools, cpu)[highpri]);</span><br><span class="line"></span><br><span class="line">			*pwq_p = kmem_cache_alloc_node(pwq_cache, GFP_KERNEL,</span><br><span class="line">						       pool-&gt;node);</span><br><span class="line">			<span class="keyword">if</span> (!*pwq_p)</span><br><span class="line">				<span class="keyword">goto</span> enomem;</span><br><span class="line"></span><br><span class="line">			init_pwq(*pwq_p, wq, pool);</span><br><span class="line"></span><br><span class="line">			mutex_lock(&amp;wq-&gt;mutex);</span><br><span class="line">			link_pwq(*pwq_p);</span><br><span class="line">			mutex_unlock(&amp;wq-&gt;mutex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trace_android_rvh_alloc_and_link_pwqs(wq, &amp;ret, &amp;skip);</span><br><span class="line">	<span class="keyword">if</span> (skip)</span><br><span class="line">		<span class="keyword">goto</span> oem_skip;</span><br><span class="line"></span><br><span class="line">	cpus_read_lock();</span><br><span class="line">	<span class="keyword">if</span> (wq-&gt;flags &amp; __WQ_ORDERED) &#123;</span><br><span class="line">		ret = apply_workqueue_attrs(wq, ordered_wq_attrs[highpri]);</span><br><span class="line">		<span class="comment">/* there should only be single pwq for ordering guarantee */</span></span><br><span class="line">		WARN(!ret &amp;&amp; (wq-&gt;pwqs.next != &amp;wq-&gt;dfl_pwq-&gt;pwqs_node ||</span><br><span class="line">			      wq-&gt;pwqs.prev != &amp;wq-&gt;dfl_pwq-&gt;pwqs_node),</span><br><span class="line">		     <span class="string">&quot;ordering guarantee broken for workqueue %s\n&quot;</span>, wq-&gt;name);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ret = apply_workqueue_attrs(wq, unbound_std_wq_attrs[highpri]);</span><br><span class="line">	&#125;</span><br><span class="line">	cpus_read_unlock();</span><br><span class="line"></span><br><span class="line">oem_skip:</span><br><span class="line">	<span class="comment">/* for unbound pwq, flush the pwq_release_worker ensures that the</span></span><br><span class="line"><span class="comment">	 * pwq_release_workfn() completes before calling kfree(wq).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		kthread_flush_worker(pwq_release_worker);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">enomem:</span><br><span class="line">	<span class="keyword">if</span> (wq-&gt;cpu_pwq) &#123;</span><br><span class="line">		for_each_possible_cpu(cpu) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span> =</span> *per_cpu_ptr(wq-&gt;cpu_pwq, cpu);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (pwq)</span><br><span class="line">				kmem_cache_free(pwq_cache, pwq);</span><br><span class="line">		&#125;</span><br><span class="line">		free_percpu(wq-&gt;cpu_pwq);</span><br><span class="line">		wq-&gt;cpu_pwq = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-work"><a href="#5-work" class="headerlink" title="5 work"></a>5 work</h2><p>work的创建并没什么好说的，使用<code>INIT_WORK</code>宏初始化work的func即可，然后调用<code>queue_work</code>或者<code>schedule_work</code> 将work压入到workqueue中。</p>
<p>最终调用的函数为<code>__queue_work()</code> ，将work填充到worker pool的work_list中，待worker执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __queue_work(<span class="type">int</span> cpu, <span class="keyword">struct</span> workqueue_struct *wq,</span><br><span class="line">			 <span class="keyword">struct</span> work_struct *work)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">last_pool</span>, *<span class="title">pool</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> work_flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> req_cpu = cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * While a work item is PENDING &amp;&amp; off queue, a task trying to</span></span><br><span class="line"><span class="comment">	 * steal the PENDING will busy-loop waiting for it to either get</span></span><br><span class="line"><span class="comment">	 * queued or lose PENDING.  Grabbing PENDING and queueing should</span></span><br><span class="line"><span class="comment">	 * happen with IRQ disabled.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	lockdep_assert_irqs_disabled();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For a draining wq, only works from the same workqueue are</span></span><br><span class="line"><span class="comment">	 * allowed. The __WQ_DESTROYING helps to spot the issue that</span></span><br><span class="line"><span class="comment">	 * queues a new work item to a wq after destroy_workqueue(wq).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(wq-&gt;flags &amp; (__WQ_DESTROYING | __WQ_DRAINING) &amp;&amp;</span><br><span class="line">		     WARN_ON_ONCE(!is_chained_work(wq))))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">retry:</span><br><span class="line">	<span class="comment">/* pwq which will be used unless @work is executing elsewhere */</span></span><br><span class="line">	<span class="keyword">if</span> (req_cpu == WORK_CPU_UNBOUND) &#123;</span><br><span class="line">		<span class="keyword">if</span> (wq-&gt;flags &amp; WQ_UNBOUND)</span><br><span class="line">			cpu = wq_select_unbound_cpu(raw_smp_processor_id());</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			cpu = raw_smp_processor_id();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pwq = rcu_dereference(*per_cpu_ptr(wq-&gt;cpu_pwq, cpu));</span><br><span class="line">	pool = pwq-&gt;pool;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If @work was previously on a different pool, it might still be</span></span><br><span class="line"><span class="comment">	 * running there, in which case the work needs to be queued on that</span></span><br><span class="line"><span class="comment">	 * pool to guarantee non-reentrancy.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	last_pool = get_work_pool(work);</span><br><span class="line">	<span class="keyword">if</span> (last_pool &amp;&amp; last_pool != pool) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span>;</span></span><br><span class="line"></span><br><span class="line">		raw_spin_lock(&amp;last_pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">		worker = find_worker_executing_work(last_pool, work);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (worker &amp;&amp; worker-&gt;current_pwq-&gt;wq == wq) &#123;</span><br><span class="line">			pwq = worker-&gt;current_pwq;</span><br><span class="line">			pool = pwq-&gt;pool;</span><br><span class="line">			WARN_ON_ONCE(pool != last_pool);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* meh... not running there, queue here */</span></span><br><span class="line">			raw_spin_unlock(&amp;last_pool-&gt;lock);</span><br><span class="line">			raw_spin_lock(&amp;pool-&gt;lock);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		raw_spin_lock(&amp;pool-&gt;lock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * pwq is determined and locked. For unbound pools, we could have raced</span></span><br><span class="line"><span class="comment">	 * with pwq release and it could already be dead. If its refcnt is zero,</span></span><br><span class="line"><span class="comment">	 * repeat pwq selection. Note that unbound pwqs never die without</span></span><br><span class="line"><span class="comment">	 * another pwq replacing it in cpu_pwq or while work items are executing</span></span><br><span class="line"><span class="comment">	 * on it, so the retrying is guaranteed to make forward-progress.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!pwq-&gt;refcnt)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (wq-&gt;flags &amp; WQ_UNBOUND) &#123;</span><br><span class="line">			raw_spin_unlock(&amp;pool-&gt;lock);</span><br><span class="line">			cpu_relax();</span><br><span class="line">			<span class="keyword">goto</span> retry;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* oops */</span></span><br><span class="line">		WARN_ONCE(<span class="literal">true</span>, <span class="string">&quot;workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt&quot;</span>,</span><br><span class="line">			  wq-&gt;name, cpu);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* pwq determined, queue */</span></span><br><span class="line">	trace_workqueue_queue_work(req_cpu, pwq, work);</span><br><span class="line"></span><br><span class="line">	trace_android_vh_wq_queue_work(work, wq-&gt;name, wq-&gt;flags, cpu);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(!list_empty(&amp;work-&gt;entry)))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	pwq-&gt;nr_in_flight[pwq-&gt;work_color]++;</span><br><span class="line">	work_flags = work_color_to_flags(pwq-&gt;work_color);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(pwq-&gt;nr_active &lt; pwq-&gt;max_active)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (list_empty(&amp;pool-&gt;worklist))</span><br><span class="line">			pool-&gt;watchdog_ts = jiffies;</span><br><span class="line"></span><br><span class="line">		trace_workqueue_activate_work(work);</span><br><span class="line">		pwq-&gt;nr_active++;</span><br><span class="line">		insert_work(pwq, work, &amp;pool-&gt;worklist, work_flags);</span><br><span class="line">		kick_pool(pool);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		work_flags |= WORK_STRUCT_INACTIVE;</span><br><span class="line">		insert_work(pwq, work, &amp;pwq-&gt;inactive_works, work_flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	raw_spin_unlock(&amp;pool-&gt;lock);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，使用<code>alloc_workqueue()</code>创建自己的workqueue并不能拥有比系统workqueue更高的优先级，只是为了提供更精细或者定制的行为配置，比如：</p>
<ol>
<li>设置并发度<code>max_actions</code> </li>
<li>设置flags（绑定至某个cpu、优先级、是否在suspend时被freeze等）</li>
</ol>
<h2 id="6-Reference"><a href="#6-Reference" class="headerlink" title="6 Reference"></a>6 Reference</h2><ul>
<li><a href="https://www.kernel.org/doc/html/latest/core-api/workqueue.html">https://www.kernel.org/doc/html/latest/core-api/workqueue.html</a></li>
<li><a href="https://kernel.meizu.com/2016/08/21//linux-workqueue.html/">https://kernel.meizu.com/2016/08/21//linux-workqueue.html/</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/91106844">https://zhuanlan.zhihu.com/p/91106844</a></li>
</ul>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
