<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HttpWebSever概述</title>
    <url>/2022/03/11/HttpWebSever/</url>
    <content><![CDATA[<p>根据游双老师的Linux高性能服务器编程做的一个轻量级Linux服务器，项目地址<a href="https://github.com/wangbi0912/light_web_server">GitHub</a></p>
<span id="more"></span>

<h3 id="1、项目概述"><a href="#1、项目概述" class="headerlink" title="1、项目概述"></a>1、项目概述</h3><p><strong>基于Linux的轻量级服务器</strong>，主要目的是学习巩固APUE、UNP卷1、UNP卷2的知识。</p>
<ul>
<li>使用**线程池+epoll+Reactor事件模式(Proactor)**的并发模型</li>
<li>使用**有限状态机(FSM)**解析HTTP请求报文</li>
<li>经过Webbench压力测试能够实现C10K的并发连接</li>
</ul>
<h4 id="1-1-工作流程"><a href="#1-1-工作流程" class="headerlink" title="1.1 工作流程"></a>1.1 工作流程</h4><p>服务器首先创建一个监听<code>socket</code>为<code>listen_fd</code>，并添加到epoll事件表中，浏览器向服务器发起请求连接，首先进行TCP三次握手，服务端监测到<code>listen_fd</code>有事件发生，服务端<code>accept</code>阻塞后返回一个新的<code>socket_fd</code>，并继续添加到内核事件表中。</p>
<ul>
<li><strong>Reactor：</strong>若<code>epoll_wait</code>返回的为<code>socket_fd</code>，主线程将其插入到工作队列，通知线程池处理（读写请求，接受新连接），<strong>通常由同步I&#x2F;O实现</strong></li>
</ul>
<p><img src="https://i.loli.net/2020/05/29/9DlXZPUygOrHbE2.png" alt="Reactor"></p>
<ul>
<li><strong>Proactor：</strong>主线程和内核负责读写数据接受请求，然后将解析后的请求插入到工作队列，由线程池负责业务逻辑，<strong>通常由异步I&#x2F;O实现</strong></li>
</ul>
<p><img src="https://i.loli.net/2020/05/29/lvdktpU5xYXwPTg.png" alt="Proactor"></p>
<blockquote>
<p><strong>也可以使用同步I&#x2F;O模拟Proactor模式，提高服务器并发性能</strong></p>
</blockquote>
<ol>
<li>主线程往epoll内核事件表注册socket上的读就绪事件。</li>
<li>主线程调用epoll_wait等待socket上有数据可读</li>
<li>当socket上有数据可读，epoll_wait通知主线程,主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li>
<li>睡眠在请求队列上某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件</li>
<li>主线程调用epoll_wait等待socket可写。</li>
<li>当socket上有数据可写，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。</li>
</ol>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>NOTICE</title>
    <url>/2021/07/09/Notice/</url>
    <content><![CDATA[<p><strong>之前电脑数据没了，重新搭建博客，之前文章在恢复中…</strong></p>
]]></content>
  </entry>
  <entry>
    <title>malloc、STL空间配置器</title>
    <url>/2022/06/19/malloc%E3%80%81STL%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/</url>
    <content><![CDATA[<blockquote>
<p>malloc一直是困惑我好久的事情，今天记录一下。</p>
</blockquote>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*源码描述</span></span><br><span class="line"><span class="comment">  The main properties of the algorithms are:</span></span><br><span class="line"><span class="comment">  * For large (&gt;= 512 bytes) requests, it is a pure best-fit allocator,</span></span><br><span class="line"><span class="comment">    with ties normally decided via FIFO (i.e. least recently used).</span></span><br><span class="line"><span class="comment">  * For small (&lt;= 64 bytes by default) requests, it is a caching</span></span><br><span class="line"><span class="comment">    allocator, that maintains pools of quickly recycled chunks.</span></span><br><span class="line"><span class="comment">  * In between, and for combinations of large and small requests, it does</span></span><br><span class="line"><span class="comment">    the best it can trying to meet both goals at once.</span></span><br><span class="line"><span class="comment">  * For very large requests (&gt;= 128KB by default), it relies on system</span></span><br><span class="line"><span class="comment">    memory mapping facilities, if supported.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>malloc</code>工作原理<ol>
<li><code>malloc</code>开始搜索空闲内存块，如果能找到一块大小合适的就分配出去</li>
<li>如果<code>malloc</code>找不到一块合适的空闲内存，那么调用brk等系统调用扩大堆区从而获得更多的空闲内存（这里使用<code>brk</code>还是<code>mmap</code>取决于申请的大小）</li>
<li><code>malloc</code>调用<code>brk</code>后开始转入内核态，此时操作系统中的虚拟地址系统开始工作，扩大进程的堆区，操作系统并没有为此分配真正的物理内存</li>
<li><code>brk</code>执行结束后返回到<code>malloc</code>，从内核态切换到用户态，<code>malloc</code>找到一块合适的空闲内存后返回</li>
<li>进程拿到内存，继续干活。</li>
<li>当有代码读写新申请的内存时系统内部出现缺页中断，此时再次由用户态切换到内核态，操作系统此时真正的分配物理内存，之后再次由内核态切换回用户态，程序继续。</li>
</ol>
</li>
</ul>
<hr>
<ul>
<li>SGI STL空间配置器</li>
</ul>
<p>考虑到小型区块可能造成内存碎片问题，SGI 采用两级配置器，第一级配置器直接使用 <code>malloc()</code> 和 <code>free()</code>实现；第二级配置器使用 memory pool 内存池管理。</p>
<p>第二级配置器的原理：</p>
<ul>
<li>当配置区块超过 128 bytes，就使用第一级配置器</li>
<li>当配置区块小于 128 bytes，使用内存池管理</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;_ALIGN = <span class="number">8</span>&#125;;  <span class="comment">// 小型区块的上调边界</span></span><br><span class="line"><span class="keyword">enum</span> &#123;_MAX_BYTES = <span class="number">128</span>&#125;; <span class="comment">// 小区区块的上限</span></span><br><span class="line"><span class="keyword">enum</span> &#123;_NFREELISTS = <span class="number">16</span>&#125;; <span class="comment">// _MAX_BYTES/_ALIGN  free-list 的个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// free-list 的节点结构，降低维护链表 list 带来的额外负担</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">_Obj</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">_Obj</span>* _M_free_list_link;  <span class="comment">// 利用联合体特点</span></span><br><span class="line">    <span class="type">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this. */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> _Obj* __STL_VOLATILE _S_free_list[_NFREELISTS];  <span class="comment">// 注意，它是数组，每个数组元素包含若干相等的小额区块</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>free-list </code>是指针数组，16 个数组元素，就是 16 个 <code>free-list</code>，各自管理大小分别为 8， 16， 24， 32，…128 bytes(8 的倍数)的小额区块。</p>
<p>小额区块的结构体 union _Obj 使用链表连接起来。如图所示：<br><img src="https://upload-images.jianshu.io/upload_images/27610647-53a735a6284192db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>配置器负责配置，同时也负责回收。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>shared_str、String类实现</title>
    <url>/2022/05/11/shared-str%E3%80%81String%E7%B1%BB%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>实现<code>shared_ptr</code>和<code>String</code>类，分析<code>shared_ptr</code>线程安全问题。</p>
<span id="more"></span>

<h2 id="一、shared-ptr使用方法"><a href="#一、shared-ptr使用方法" class="headerlink" title="一、shared_ptr使用方法"></a>一、<code>shared_ptr</code>使用方法</h2><p>使用该智能指针（或者其他两种）需要导入头文件<code>#include &lt;memory&gt;</code></p>
<ul>
<li>创建空指针<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p1;             <span class="comment">//不传入任何实参</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;    <span class="comment">//传入空指针 nullptr</span></span><br></pre></td></tr></table></figure></li>
<li>明确指向<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p4 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);  <span class="comment">//推荐使用make_shared&lt;T&gt;构造</span></span><br></pre></td></tr></table></figure></li>
<li>拷贝构造<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(p3)</span></span>;</span><br></pre></td></tr></table></figure>
除此之外还可以对<code>shared_ptr</code>赋值，通过重写<code>operator=</code>实现。<strong>需要注意</strong>，对于<code>p1=p2</code>（均为智能指针）这种，<code>p2</code>所指对象由于被<code>p1</code>指向，所以该引用计数会加一，<code>p1</code>原本指向的资源的引用计数会减一。这也会引出下面关于<code>shared_ptr</code>指针的<strong>线程安全</strong>问题。</li>
</ul>
<hr>
<h2 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存在问题：引用计数不增加</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//已解决：重载()函数换成拷贝构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mShared_ptr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _ptr;</span><br><span class="line">    <span class="type">int</span>* _refcount;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mShared_ptr</span>() : _ptr(<span class="keyword">new</span> <span class="built_in">T</span>()), _refcount(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mShared_ptr</span>(T* obj) : _ptr(obj), _refcount(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">mShared_ptr</span>() &#123;</span><br><span class="line">        --(*_refcount);</span><br><span class="line">        <span class="keyword">if</span>(_ptr &amp;&amp; (*_refcount) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">            <span class="keyword">delete</span> _refcount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mShared_ptr</span> (<span class="type">const</span> mShared_ptr&amp; _other) &#123;</span><br><span class="line">        ++*_other._refcount;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;_ref : &quot;</span> &lt;&lt; *_other._refcount &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_ptr = _other._ptr;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_refcount = _other._refcount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mShared_ptr&amp; <span class="keyword">operator</span>= (<span class="type">const</span> mShared_ptr&amp; _other) &#123;</span><br><span class="line">        <span class="keyword">if</span>(_other == *<span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        --*(<span class="keyword">this</span>-&gt;_refcount);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;_ptr &amp;&amp; *(<span class="keyword">this</span>-&gt;_refcount) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_refcount;</span><br><span class="line">        &#125;</span><br><span class="line">        ++*_other._refcount;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;_ref : &quot;</span> &lt;&lt; *_other._refcount &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_ptr = _other._ptr;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_refcount = _other._refcount;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>* () &#123;</span><br><span class="line">        <span class="keyword">return</span> *_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt; () &#123;</span><br><span class="line">        <span class="keyword">return</span> _ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_refcount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_refcount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">mShared_ptr&lt;<span class="type">int</span>&gt; <span class="title">obj</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    mShared_ptr&lt;<span class="type">int</span>&gt; obj2 = obj;</span><br><span class="line">    <span class="function">mShared_ptr&lt;<span class="type">int</span>&gt; <span class="title">obj3</span><span class="params">(obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; *obj &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *obj2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *obj3 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; obj.<span class="built_in">get_refcount</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; obj2.<span class="built_in">get_refcount</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; obj3.<span class="built_in">get_refcount</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">root@iZuf6ccxsb4mprtz1c1mx2Z:~/<span class="title">Linux</span>/<span class="title">Test</span>/<span class="title">DataStructure</span># ./<span class="title">mShared_ptr</span> </span></span><br><span class="line"><span class="function"><span class="title">_ref</span> : 2</span></span><br><span class="line"><span class="function"><span class="title">_ref</span> : 3</span></span><br><span class="line"><span class="function">10</span></span><br><span class="line"><span class="function">10</span></span><br><span class="line"><span class="function">10</span></span><br><span class="line"><span class="function">3</span></span><br><span class="line"><span class="function">3</span></span><br><span class="line"><span class="function">3</span></span><br></pre></td></tr></table></figure>
<p>这里实现的还有一些问题，因为<code>shared_ptr</code>源码中关于引用计数是<strong>原子操作</strong>，不需要考虑资源使用冲突的问题，可以在自己实现的时候加锁。</p>
<hr>
<h2 id="三、关于shared-ptr的线程安全问题"><a href="#三、关于shared-ptr的线程安全问题" class="headerlink" title="三、关于shared_ptr的线程安全问题"></a>三、关于<code>shared_ptr</code>的线程安全问题</h2><p>首先什么是线程安全？<br>简单来说就是<strong>多个线程操作一个共享数据，都能按照预期的行为进行，无论多个线程的运行次序如何交织。</strong></p>
<p>对于<code>shared_ptr</code>，其内部有两个变量，引用计数和真正的对象类型指针。其中引用计数是原子操作，所以<strong>对于<code>shared_ptr</code>的读操作是线程安全的。</strong></p>
<p>但是对于<code>shared_ptr</code>中赋值如<code>ptr1 = ptr2</code>，需要两个步骤，<strong>1、<code>ptr1</code>的内部对象指针<code>Obj1</code>替换成<code>ptr2</code>内部对象<code>Obj2</code>指针；2、<code>ptr1</code>的对于<code>Obj1</code>的引用计数缓存<code>Obj2</code>的引用计数。</strong></p>
<p>这两步并不是原子的，如果一个线程需要对<code>shared_ptr</code>进行赋值操作<code>ptr1 = ptr2</code>，刚完成第一步，就切换到其他线程又对ptr2进行操作，如<code>ptr2 = ptr3</code>，就有可能造成析构了引用计数。而继续之前线程的第二步，就会出错。</p>
<p><strong>总之：对于<code>shared_ptr</code>的读操作是线程安全的。<br>对于<code>shared_ptr</code>读写操作不是线程安全的，需要加锁。</strong></p>
<hr>
<p>tips：为什么<code>shared_ptr</code>的引用计数能够同步到不同的指针中？</p>
<p>有人回答可能使用的是static变量，这是不可能的，因为一个类中只有一个静态变量，只能记录对于一个对象的引用次数，这在包含两个<code>shared_ptr</code>以上的程序中是不可行的。<br>个人认为是引用计数是用指针实现的，指向一个记录引用次数的对象。</p>
<hr>
<h2 id="四、String类实现"><a href="#四、String类实现" class="headerlink" title="四、String类实现"></a>四、String类实现</h2><h2 id="String和strcpy函数"><a href="#String和strcpy函数" class="headerlink" title="String和strcpy函数"></a>String和strcpy函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现string类</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mString</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* _data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mString</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            _data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(_data, str);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _data = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">            *_data = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mString</span>(<span class="type">const</span> mString&amp; str) &#123;</span><br><span class="line">        _data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str._data) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_data, str._data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mString&amp; <span class="keyword">operator</span>= (<span class="type">const</span> mString&amp; str) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;_data == str._data) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;_data;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str._data) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;_data, str._data);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">mString</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] _data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">mString <span class="title">str1</span><span class="params">(<span class="string">&quot;woshinidie&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">mString <span class="title">str2</span><span class="params">(str1)</span></span>;</span><br><span class="line">    mString str3 = str1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; str1.<span class="built_in">data</span>()[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; str2.<span class="built_in">data</span>()[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; str3.<span class="built_in">data</span>()[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现strcpy函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">mStrcpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!dest || !source)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>((*dest++ = *source++) != <span class="string">&#x27;\0&#x27;</span>) &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> s2[<span class="number">20</span>] = <span class="string">&quot;fashdfk&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* s1 = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s2) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">mStrcpy</span>(s1, s2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; s1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>webserver基本知识</title>
    <url>/2022/03/27/webserver%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="1、基础知识"><a href="#1、基础知识" class="headerlink" title="1、基础知识"></a>1、基础知识</h2><h4 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a><strong>RAII</strong></h4><span id="more"></span>

<ul>
<li>RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”.</li>
<li>在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定</li>
<li>RAII的核心思想是将资源或者状态与对象的生命周期绑定，通过C++的语言机制，实现资源和状态的安全管理,智能指针是RAII最好的例子</li>
</ul>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a><strong>信号量</strong></h4><p>信号量是一种特殊的变量，它只能取自然数值并且只支持两种操作：等待(P)和信号(V).假设有信号量SV，对其的P、V操作如下：</p>
<blockquote>
<ul>
<li>P，如果SV的值大于0，则将其减一；若SV的值为0，则挂起执行</li>
<li>V，如果有其他进行因为等待SV而挂起，则唤醒；若没有，则将SV值加一</li>
</ul>
</blockquote>
<p>信号量的取值可以是任何自然数，最常用的，最简单的信号量是二进制信号量，只有0和1两个值.</p>
<blockquote>
<ul>
<li>sem_init函数用于初始化一个未命名的信号量</li>
<li>sem_destory函数用于销毁信号量</li>
<li>sem_wait函数将以原子操作方式将信号量减一,信号量为0时,sem_wait阻塞</li>
<li>sem_post函数以原子操作方式将信号量加一,信号量大于0时,唤醒调用sem_post的线程</li>
</ul>
</blockquote>
<p>以上，成功返回0，失败返回errno</p>
<h4 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a><strong>互斥量</strong></h4><p>互斥锁,也成互斥量,可以保护关键代码段,以确保独占式访问.当进入关键代码段,获得互斥锁将其加锁;离开关键代码段,唤醒等待该互斥锁的线程.</p>
<blockquote>
<ul>
<li>pthread_mutex_init函数用于初始化互斥锁</li>
<li>pthread_mutex_destory函数用于销毁互斥锁</li>
<li>pthread_mutex_lock函数以原子操作方式给互斥锁加锁</li>
<li>pthread_mutex_unlock函数以原子操作方式给互斥锁解锁</li>
</ul>
</blockquote>
<p>以上，成功返回0，失败返回errno</p>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a><strong>条件变量</strong></h4><p>条件变量提供了一种线程间的通知机制,当某个共享数据达到某个值时,唤醒等待这个共享数据的线程.</p>
<blockquote>
<ul>
<li>pthread_cond_init函数用于初始化条件变量</li>
<li>pthread_cond_destory函数销毁条件变量</li>
<li>pthread_cond_broadcast函数以广播的方式唤醒<strong>所有</strong>等待目标条件变量的线程</li>
<li>pthread_cond_wait函数用于等待目标条件变量.该函数调用时需要传入 <strong>mutex参数(加锁的互斥锁)</strong> ,函数执行时,先把调用线程放入条件变量的请求队列,然后将互斥锁mutex解锁,当函数成功返回为0时,互斥锁会再次被锁上. <strong>也就是说函数内部会有一次解锁和加锁操作</strong>.</li>
</ul>
</blockquote>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><h4 id="锁机制的功能"><a href="#锁机制的功能" class="headerlink" title="锁机制的功能"></a><strong>锁机制的功能</strong></h4><ul>
<li>实现多线程同步，通过锁机制，确保任一时刻只能有一个线程能进入关键代码段.</li>
</ul>
<h4 id="封装的功能"><a href="#封装的功能" class="headerlink" title="封装的功能"></a><strong>封装的功能</strong></h4><ul>
<li>类中主要是Linux下三种锁进行封装，将锁的创建于销毁函数封装在类的构造与析构函数中，实现RAII机制</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 1class sem&#123;</span><br><span class="line"> 2    public:</span><br><span class="line"> 3        //构造函数</span><br><span class="line"> 4        sem()</span><br><span class="line"> 5        &#123;</span><br><span class="line"> 6            //信号量初始化</span><br><span class="line"> 7            if(sem_init(&amp;m_sem,0,0)!=0)&#123;</span><br><span class="line"> 8                throw std::exception();</span><br><span class="line"> 9            &#125;</span><br><span class="line">10        &#125;</span><br><span class="line">11        //析构函数</span><br><span class="line">12        ~sem()</span><br><span class="line">13        &#123;</span><br><span class="line">14            //信号量销毁</span><br><span class="line">15            sem_destroy(&amp;m_sem);</span><br><span class="line">16        &#125;</span><br><span class="line">17    private:</span><br><span class="line">18        sem_t m_sem;</span><br><span class="line">19&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>将重复使用的代码封装为函数，减少代码的重复，使其更简洁</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 1   //条件变量的使用机制需要配合锁来使用</span><br><span class="line"> 2   //内部会有一次加锁和解锁</span><br><span class="line"> 3   //封装起来会使得更加简洁</span><br><span class="line"> 4   bool wait()</span><br><span class="line"> 5   &#123;</span><br><span class="line"> 6       int ret=0;</span><br><span class="line"> 7       pthread_mutex_lock(&amp;m_mutex);</span><br><span class="line"> 8       ret=pthread_cond_wait(&amp;m_cond,&amp;m_mutex);</span><br><span class="line"> 9       pthread_mutex_unlock(&amp;m_mutex);</span><br><span class="line">10       return ret==0;</span><br><span class="line">11   &#125;</span><br><span class="line">12   bool signal()</span><br><span class="line">13   &#123;</span><br><span class="line">14       return pthread_cond_signal(&amp;m_cond)==0;</span><br><span class="line">15   &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2、半同步半异步-线程池"><a href="#2、半同步半异步-线程池" class="headerlink" title="2、半同步半异步+线程池"></a>2、半同步半异步+线程池</h2><h3 id="服务器编程基本框架"><a href="#服务器编程基本框架" class="headerlink" title="服务器编程基本框架"></a>服务器编程基本框架</h3><p>主要由I&#x2F;O单元，逻辑单元和网络存储单元组成，其中每个单元之间通过请求队列进行通信，从而协同完成任务。</p>
<p>其中I&#x2F;O单元用于处理客户端连接，读写网络数据；逻辑单元用于处理业务逻辑的线程；网络存储单元指本地数据库和文件等。</p>
<p><img src="https://i.loli.net/2020/05/29/iVTuxoOaQvYcSrA.png" alt="image-20200529181932994"></p>
<h3 id="五种I-x2F-O模型"><a href="#五种I-x2F-O模型" class="headerlink" title="五种I&#x2F;O模型"></a>五种I&#x2F;O模型</h3><ul>
<li><strong>阻塞IO</strong>:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作</li>
<li><strong>非阻塞IO</strong>:非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I&#x2F;O执行系统调用总是立即返回，不管时间是否已经发生，若时间没有发生，则返回-1，此时可以根据errno区分这两种情况，对于accept，recv和send，事件未发生时，errno通常被设置成eagain</li>
<li><strong>信号驱动IO</strong>:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。</li>
<li><strong>IO复用</strong>:linux用select&#x2F;poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数</li>
<li><strong>异步IO</strong>:linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</li>
</ul>
<p><strong>注意：阻塞I&#x2F;O，非阻塞I&#x2F;O，信号驱动I&#x2F;O和I&#x2F;O复用都是同步I&#x2F;O。同步I&#x2F;O指内核向应用程序通知的是就绪事件，比如只通知有客户端连接，要求用户代码自行执行I&#x2F;O操作，异步I&#x2F;O是指内核向应用程序通知的是完成事件，比如读取客户端的数据后才通知应用程序，由内核完成I&#x2F;O操作。</strong></p>
<h3 id="事件处理模式"><a href="#事件处理模式" class="headerlink" title="事件处理模式"></a>事件处理模式</h3><ul>
<li>reactor模式中，主线程(<strong>I&#x2F;O处理单元</strong>)只负责监听文件描述符上是否有事件发生，有的话立即通知工作线程(<strong>逻辑单元</strong> )，读写数据、接受新连接及处理客户请求均在工作线程中完成。通常由<strong>同步I&#x2F;O</strong>实现。</li>
</ul>
<p><img src="https://i.loli.net/2020/05/29/9DlXZPUygOrHbE2.png" alt="image-20200529182048896"></p>
<ul>
<li>proactor模式中，主线程和内核负责处理读写数据、接受新连接等I&#x2F;O操作，工作线程仅负责业务逻辑，如处理客户请求。通常由<strong>异步I&#x2F;O</strong>实现。</li>
</ul>
<p><img src="https://i.loli.net/2020/05/29/lvdktpU5xYXwPTg.png" alt="image-20200529182104068"></p>
<h3 id="同步I-x2F-O模拟proactor模式"><a href="#同步I-x2F-O模拟proactor模式" class="headerlink" title="同步I&#x2F;O模拟proactor模式"></a>同步I&#x2F;O模拟proactor模式</h3><p>由于异步I&#x2F;O并不成熟，实际中使用较少，这里将使用同步I&#x2F;O模拟实现proactor模式。</p>
<p>同步I&#x2F;O模型的工作流程如下（epoll_wait为例）：</p>
<blockquote>
<ul>
<li>主线程往epoll内核事件表注册socket上的读就绪事件。</li>
<li>主线程调用epoll_wait等待socket上有数据可读</li>
<li>当socket上有数据可读，epoll_wait通知主线程,主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li>
<li>睡眠在请求队列上某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件</li>
<li>主线程调用epoll_wait等待socket可写。</li>
<li>当socket上有数据可写，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。</li>
</ul>
</blockquote>
<p><img src="https://i.loli.net/2020/05/29/pWNfHEBucjs5JVm.png" alt="image-20200529182127823"></p>
<h3 id="并发编程模式"><a href="#并发编程模式" class="headerlink" title="并发编程模式"></a>并发编程模式</h3><p>并发编程方法的实现有多线程和多进程两种，但这里涉及的并发模式指I&#x2F;O处理单元与逻辑单元的协同完成任务的方法。</p>
<ul>
<li>半同步&#x2F;半异步模式</li>
<li>领导者&#x2F;追随者模式</li>
</ul>
<h3 id="半同步-x2F-半反应堆"><a href="#半同步-x2F-半反应堆" class="headerlink" title="半同步&#x2F;半反应堆"></a>半同步&#x2F;半反应堆</h3><p>半同步&#x2F;半反应堆并发模式是半同步&#x2F;半异步的变体，将半异步具体化为某种事件处理模式.</p>
<p>并发模式中的同步和异步</p>
<blockquote>
<ul>
<li>同步指的是程序完全按照代码序列的顺序执行</li>
<li>异步指的是程序的执行需要由系统事件驱动</li>
</ul>
</blockquote>
<p><img src="https://i.loli.net/2020/05/29/Fm5ZJfUShDcNWov.png" alt="image-20200529182211696"></p>
<p>半同步&#x2F;半异步模式工作流程</p>
<blockquote>
<ul>
<li>同步线程用于处理客户逻辑</li>
<li>异步线程用于处理I&#x2F;O事件</li>
<li>异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中</li>
<li>请求队列将通知某个工作在<strong>同步模式的工作线程</strong>来读取并处理该请求对象</li>
</ul>
</blockquote>
<p><img src="https://i.loli.net/2020/05/29/lRNaU6hMACiWdg7.png" alt="image-20200529182234142"></p>
<p>半同步&#x2F;半反应堆工作流程（以Proactor模式为例）</p>
<blockquote>
<ul>
<li>主线程充当异步线程，负责监听所有socket上的事件</li>
<li>若有新请求到来，主线程接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件</li>
<li>如果连接socket上有读写事件发生，主线程从socket上接收数据，并将数据封装成请求对象插入到请求队列中</li>
<li>所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权</li>
</ul>
</blockquote>
<p><img src="https://i.loli.net/2020/05/29/9s5Vz8nThU6jD4X.png" alt="image-20200529182418750"></p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul>
<li>空间换时间,浪费服务器的硬件资源,换取运行效率.</li>
<li>池是一组资源的集合,这组资源在服务器启动之初就被完全创建好并初始化,这称为静态资源.</li>
<li>当服务器进入正式运行阶段,开始处理客户请求的时候,如果它需要相关的资源,可以直接从池中获取,无需动态分配.</li>
<li>当服务器处理完一个客户连接后,可以把相关的资源放回池中,无需执行系统调用释放资源.</li>
</ul>
<blockquote>
<p> 线程池实现可以见我另外一篇博客</p>
</blockquote>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树（一）</title>
    <url>/2021/06/12/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h3 id="文章对应的题目"><a href="#文章对应的题目" class="headerlink" title="文章对应的题目"></a>文章对应的题目</h3><p>230  BST第K小的元素<br>538  二叉搜索树转化为累加树</p>
<span id="more"></span>

<hr>
<h3 id="二叉搜索树BST特性："><a href="#二叉搜索树BST特性：" class="headerlink" title="二叉搜索树BST特性："></a>二叉搜索树BST特性：</h3><p>1、对于BST上每个节点<code>node</code>，左子树的节点的值都比<code>node</code>的值要小，右子树节点的值都比<code>node</code>的值要大。<br>2、对于BST的每一个节点<code>node</code>，他的左侧子树<code>node -&gt; left</code>和右侧子树<code>node -&gt; right</code>都为BST。<br>3、对BST做<strong>中序遍历</strong>，得到的遍历结果是<strong>升序</strong>的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对BST做中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traverse</span>(root -&gt; left);</span><br><span class="line">    cout &lt;&lt; root -&gt; val &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">traverse</span>(root -&gt; right);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="230-寻找第K小的元素"><a href="#230-寻找第K小的元素" class="headerlink" title="230. 寻找第K小的元素"></a>230. 寻找第K小的元素</h1><p><img src="/2021/06/12/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88%E4%B8%80%EF%BC%89/230.png" alt="230. 寻找第K小的元素"><br>题目需求如上，直接思路就是中序遍历，找到排名第K的元素，代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> res= <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traverse</span>(root, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traverse</span>(root -&gt; left, k);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i == k) &#123;</span><br><span class="line">            res = root -&gt; val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traverse</span>(root -&gt; right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为<code>O(N)</code>，像红黑树这种自平衡的BST，增删查改时间复杂度都是对数级的<code>O(logN)</code>，所以说有点低效。<br>若要达到对数级的时间复杂度，就需要知道当前的节点的排名是多少（类似于二分查找）。<br>比如说你让我查找排名为k的元素，当前节点知道自己排名第<code>m</code>，那么我可以比较<code>m</code>和<code>k</code>的大小：</p>
<p>1、如果<code>m == k</code>，显然就是找到了第<code>k</code>个元素，返回当前节点就行了。<br>2、如果<code>k &lt; m</code>，那说明排名第k的元素在左子树，所以可以去左子树搜索第<code>k</code>个元素。<br>3、如果<code>k &gt; m</code>，那说明排名第k的元素在右子树，所以可以去右子树搜索第<code>k - m - 1</code>个元素。</p>
<p>这样就可以将时间复杂度降到<code>O(logN)</code>了。这就需要在二叉树节点中维护一个排名信息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     <span class="comment">//size为当前节点为根节点的树的节点总数</span></span><br><span class="line">     <span class="type">int</span> size;</span><br><span class="line">     TreeNode *left;</span><br><span class="line">     TreeNode *right;</span><br><span class="line">     <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>这样就可以将排名<code>k</code>和<code>node -&gt; left -&gt; size</code>对比，达到对数级的时间复杂度。</p>
<hr>
<h3 id="二叉搜索树转化为累加树"><a href="#二叉搜索树转化为累加树" class="headerlink" title="二叉搜索树转化为累加树"></a>二叉搜索树转化为累加树</h3><p><img src="/2021/06/12/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88%E4%B8%80%EF%BC%89/538.png" alt="二叉搜索树转化为累加树"><br>其实就是利用二叉树的中序遍历特性，本题直接利用降序输出即可，递归顺序为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == nullprt)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traverse</span>(root -&gt; right);</span><br><span class="line">    cout &lt;&lt; root -&gt; val &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">traverse</span>(root -&gt; left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码可以从大到小降序打印 BST 节点的值，如果维护一个外部累加变量<code>sum</code>，然后把<code>sum</code>赋值给 BST 中的每一个节点，就可以将 BST 转化成累加树。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">GST</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">GST</span>(root -&gt; right);</span><br><span class="line">        sum += root -&gt; val;</span><br><span class="line">        root -&gt; val = sum;</span><br><span class="line">        <span class="built_in">GST</span>(root -&gt; left);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>[labuladong公众号](<a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247488101&idx=1&sn=6041ddda5f20ccde8a7036d3e3a1482c&chksm=9bd7ec6daca0657b2ab20a936437e2c8206384c3b1485fe91747ad796fa3a5b08556b2f4911e&scene=21#wechat_redirect">手把手刷二叉搜索树（第一期） (qq.com)</a>)</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树（三）</title>
    <url>/2021/06/15/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h3 id="文章对应的题目"><a href="#文章对应的题目" class="headerlink" title="文章对应的题目"></a>文章对应的题目</h3><p>96 不同的二叉搜索树<br>95 不同的二叉搜索树II</p>
<span id="more"></span>

<hr>
<h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96.不同的二叉搜索树"></a>96.不同的二叉搜索树</h3><p><img src="https://upload-images.jianshu.io/upload_images/27610647-fb884c22652bbbb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="96.不同的二叉搜索树"><br>若输入<code>n=3</code>，总共有5种BST，结果为5，这就需要<strong>穷举</strong>。<br>若<code>n=5</code>，或者说用<code>&#123;1, 2, 3, 4, 5&#125;</code>构造平衡二叉树，首先每一个点都能作为根节点，若我们固定<code>3</code>为根节点，左子树为<code>&#123;1, 2&#125;</code>，右子树为<code>&#123;4, 5&#125;</code>，左右两棵子树分别有2种情况。所以对于固定<code>3</code>为根节点这个情况来讲，共有<strong>2x2&#x3D;4</strong>种结果.<br>对于如何计算左子树<code>&#123;1, 2&#125;</code>、右子树<code>&#123;4, 5&#125;</code>的情况，这是一个计算树的组合的子问题，直接用递归即可。需要一个辅助函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span></span>;  <span class="comment">//闭区间[low, high]的数字能组成count(low, high)种BST</span></span><br></pre></td></tr></table></figure>
<p>具体实现代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">count</span>(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &gt; high)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> mid = low; mid &lt;= high; mid++) &#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="built_in">count</span>(low, mid - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> right = <span class="built_in">count</span>(mid + <span class="number">1</span>, high);</span><br><span class="line">            res += left * right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>提交之后并不能通过，超出时间限制，因为存在<strong>重叠子问题</strong>，在动态规划中消除重叠子问题的方法，就是加一个<strong>备忘录</strong><code>memo</code>。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n)); <span class="comment">//初始化二维vector，每一个元素都为0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">count</span>(<span class="number">1</span>, n, memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &gt; high)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(memo[low - <span class="number">1</span>][high - <span class="number">1</span>] !=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[low - <span class="number">1</span>][high - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> mid = low; mid &lt;= high; mid++) &#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="built_in">count</span>(low, mid - <span class="number">1</span>, memo);</span><br><span class="line">            <span class="type">int</span> right = <span class="built_in">count</span>(mid + <span class="number">1</span>, high, memo);</span><br><span class="line">            res += left * right;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[low - <span class="number">1</span>][high - <span class="number">1</span>] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是提交之后还是超过时间限制…</p>
<hr>
<h3 id="95-不同的二叉搜索树II"><a href="#95-不同的二叉搜索树II" class="headerlink" title="95.不同的二叉搜索树II"></a>95.不同的二叉搜索树II</h3><p>此题思路和上题一样，都是遍历每一个节点作为根节点，迭代求出以当前点为根节点其他子树的树的形状。<br>具体的步骤为：</p>
<ol>
<li>穷举<code>root</code>节点的所有可能。</li>
<li>递归构造左右子树的BST。</li>
<li>穷举左右子树作为<code>root</code>的左右子树<br>具体代码如下<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(<span class="number">1</span>, n);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">build</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &gt; high) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;TreeNode*&gt; res;    <span class="comment">//保存当前root节点的结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> mid = low; mid &lt;= high; mid ++) &#123;</span><br><span class="line">            vector&lt;TreeNode*&gt; left = <span class="built_in">build</span>(low, mid - <span class="number">1</span>);</span><br><span class="line">            vector&lt;TreeNode*&gt; right = <span class="built_in">build</span>(mid + <span class="number">1</span>, high);</span><br><span class="line">            <span class="comment">//给root节点穷举所有所有子树的组合</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i : left) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> j : right) &#123;</span><br><span class="line">                    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(mid);</span><br><span class="line">                    root -&gt; left = i;</span><br><span class="line">                    root -&gt; right = j;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树（二）</title>
    <url>/2021/06/14/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h3 id="文章对应的题目"><a href="#文章对应的题目" class="headerlink" title="文章对应的题目"></a>文章对应的题目</h3><p>450 删除BST的节点（M）<br>701 二叉搜索树的插入操作（M）<br>700 二叉搜索树的搜索（E）<br>98 验证二叉搜索树</p>
<span id="more"></span>

<hr>
<p>对于BST相关的问题，基本上有一个代码框架</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root -&gt; val == target) &#123;</span><br><span class="line">        <span class="comment">//找到目标操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root -&gt; val &lt; target) &#123;</span><br><span class="line">        <span class="built_in">traverse</span>(root -&gt; right, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root -&gt; val &gt; target) &#123;</span><br><span class="line">        <span class="built_in">traverse</span>(root -&gt; left, target);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h3><p><img src="https://upload-images.jianshu.io/upload_images/27610647-9783181e5d62b6b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="98.验证二叉搜索树"></p>
<p>首先，直接思路就是递归遍历每一个节点，比较节点的左右孩子的值和本身相比，<br>但是，二叉搜索树不仅仅是对于一个节点的孩子节点相比，还要保证整个子树都要小于该节点的值，这时候需要一个辅助函数，函数签名为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_valid</span><span class="params">(TreeNode* root, TreeNode* max, TreeNode* min)</span></span>;</span><br></pre></td></tr></table></figure>
<p>辅助函数将该节点作为后续遍历节点的根节点，遍历到左子树时为<code>root</code>为<code>max</code>节点，遍历到右子树时为<code>root</code>为<code>min</code>节点。<br>正确的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValid</span>(root, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(TreeNode* root,TreeNode* max,TreeNode* min)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(max != <span class="literal">nullptr</span> &amp;&amp; root -&gt; val &gt;= max -&gt; val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(min != <span class="literal">nullptr</span> &amp;&amp; root -&gt; val &lt;= min -&gt; val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValid</span>(root -&gt; left, root, min) &amp;&amp; <span class="built_in">isValid</span>(root -&gt; right, max, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用辅助函数增加携带的参数信息，将约束传递到子树的所有节点，这是个小技巧。</p>
<hr>
<h3 id="700-二叉搜索树的搜索（E）"><a href="#700-二叉搜索树的搜索（E）" class="headerlink" title="700 二叉搜索树的搜索（E）"></a>700 二叉搜索树的搜索（E）</h3><p><img src="https://upload-images.jianshu.io/upload_images/27610647-544da1606b2d1135.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="700 二叉搜索树的搜索"></p>
<p>这题比较简单，直接递归就行，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//可以省略判别相等的情况</span></span><br><span class="line">        <span class="comment">// if(root -&gt; val == val)</span></span><br><span class="line">        <span class="comment">//     return root;</span></span><br><span class="line">        <span class="keyword">if</span>(root -&gt; val &gt; val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(root -&gt; left, val);</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; val &lt; val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(root -&gt; right, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="701-二叉搜索树的插入操作"><a href="#701-二叉搜索树的插入操作" class="headerlink" title="701 二叉搜索树的插入操作"></a>701 二叉搜索树的插入操作</h3><p><img src="https://upload-images.jianshu.io/upload_images/27610647-72a3d334adccdb60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="701 二叉搜索树的插入操作"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; val &gt; val)</span><br><span class="line">            root -&gt; left = <span class="built_in">insertIntoBST</span>(root -&gt; left, val);</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; val &lt; val)</span><br><span class="line">            root -&gt; right = <span class="built_in">insertIntoBST</span>(root -&gt; right, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; val &gt; val)</span><br><span class="line">            root -&gt; left = <span class="built_in">insertIntoBST</span>(root -&gt; left, val);</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; val &lt; val)</span><br><span class="line">            root -&gt; right = <span class="built_in">insertIntoBST</span>(root -&gt; right, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="450-删除BST的节点"><a href="#450-删除BST的节点" class="headerlink" title="450 删除BST的节点"></a>450 删除BST的节点</h3><p><img src="https://upload-images.jianshu.io/upload_images/27610647-5ad6ea611902cade.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="450 删除BST的节点"><br>要删除二叉搜索树中的节点，必须要保证删除之后二叉搜索树保持原有性质。删除节点可以分为三种情况：</p>
<ul>
<li>1、删除的节点为叶子节点，左右孩子都为<code>nullptr</code>；<br>  这种情况，直接返回<code>nullptr</code>作为上一个递归的子树；</li>
<li>2、删除的节点只有一个孩子，另一个孩子为<code>nullptr</code>；<br>  这种情况，直接返回其唯一的孩子作为上一个递归的子树；</li>
<li>3、删除的节点有两个孩子<br>  在此情况下，为了不破坏二叉搜索树的性质，必须找到该节点<code>node</code>的左子树<code>node -&gt; left</code>中的最大节点<code>maxNode</code>或右子树<code>node -&gt; right</code>中的最小节点<code>minNode</code>代替该节点，然后递归的删除其右子树<code>node -&gt; right</code>中的<code>minNode</code>（以<code>minNode</code>为例子）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; val == key) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root -&gt; left == <span class="literal">nullptr</span> &amp;&amp; root -&gt; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span>(root -&gt; left != <span class="literal">nullptr</span> &amp;&amp; root -&gt; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> root -&gt; left;</span><br><span class="line">            <span class="keyword">if</span>(root -&gt; left == <span class="literal">nullptr</span> &amp;&amp; root -&gt; right != <span class="literal">nullptr</span>) <span class="keyword">return</span> root -&gt; right;</span><br><span class="line">            TreeNode* temp = <span class="built_in">getMax</span>(root -&gt; right);</span><br><span class="line">            root -&gt; val = temp -&gt; val;</span><br><span class="line">            <span class="comment">//删除右子树的最小节点</span></span><br><span class="line">            root -&gt; right = <span class="built_in">deleteNode</span>(root -&gt; right, temp -&gt; val);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; val &gt; key) &#123;</span><br><span class="line">            root -&gt; left = <span class="built_in">deleteNode</span>(root -&gt; left, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; val &lt; key) &#123;</span><br><span class="line">            root -&gt; right = <span class="built_in">deleteNode</span>(root -&gt; right, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取右子树的最小节点</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">getMax</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root -&gt; left) &#123;</span><br><span class="line">            root = root -&gt; left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>FreeRTOS schdule</title>
    <url>/2025/05/04/FreeRTOS-schdule/</url>
    <content><![CDATA[<h2 id="1-BG"><a href="#1-BG" class="headerlink" title="1. BG"></a>1. BG</h2><p>hex</p>
]]></content>
      <tags>
        <tag>FreeRTOS</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式线程安全问题</title>
    <url>/2022/04/07/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式的实现分为懒汉和饿汉两种实现方法</p>
<ul>
<li><strong>懒汉模式：第一次用到该实例才初始化。</strong></li>
<li><strong>饿汉模式：实例创建即初始化。</strong></li>
</ul>
<blockquote>
<p>单例模式注意事项：构造函数设置为<code>private</code>；拷贝构造和<code>operator=</code>使用<code>c++11</code>的默认函数控制<code>=delete</code>（这种默认函数控制只能使用在默认构造、拷贝构造，operator&#x3D;当中）；类内的静态变量只能类内声明类外定义。</p>
</blockquote>
<span id="more"></span>

<hr>
<h3 id="饿汉实现"><a href="#饿汉实现" class="headerlink" title="饿汉实现"></a>饿汉实现</h3><p>饿汉实现较为简单，给出代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>= (<span class="type">const</span> Singleton&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">// static Singleton* m_interface;</span></span><br><span class="line">    <span class="type">static</span> shared_ptr&lt;Singleton&gt; m_interface;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Singleton</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;deconstructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> shared_ptr&lt;Singleton&gt; <span class="title">get_interface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_interface;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">shared_ptr&lt;Singleton&gt; Singleton::m_interface = <span class="built_in">shared_ptr</span>&lt;Singleton&gt;(<span class="keyword">new</span> <span class="built_in">Singleton</span>());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">worker</span><span class="params">(<span class="type">void</span>* args)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sleep&quot;</span> &lt;&lt; endl;</span><br><span class="line">    shared_ptr&lt;Singleton&gt; ptr = Singleton::<span class="built_in">get_interface</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> m_thread[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(m_thread+i, <span class="literal">NULL</span>, worker, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">pthread_detach</span>(m_thread[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于饿汉模式直接在使用该单例之前就初始化了该静态成员变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;Singleton&gt; Singleton::m_interface = <span class="built_in">shared_ptr</span>&lt;Singleton&gt;(<span class="keyword">new</span> <span class="built_in">Singleton</span>());</span><br></pre></td></tr></table></figure>
<p>所以不需要判断是否为<code>nullptr</code>，所以也没有<strong>线程安全</strong>的问题，对于内存泄漏的问题，使用<code>shared_ptr</code>进行资源释放。</p>
<hr>
<h3 id="懒汉实现"><a href="#懒汉实现" class="headerlink" title="懒汉实现"></a>懒汉实现</h3><p>基础实现方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">有缺陷的懒汉式单例模式，会有线程安全和内存泄漏问题</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有缺陷的懒汉模式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>= (<span class="type">const</span> Singleton&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">static</span> Singleton* m_interface;</span><br><span class="line">    <span class="comment">// static shared_ptr&lt;Singleton&gt; m_interface;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Singleton</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;deconstructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">get_interface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这一步并不是线程安全的</span></span><br><span class="line">        <span class="keyword">if</span>(m_interface == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">            m_interface = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_interface;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员变量只能类内声明类外定义</span></span><br><span class="line">Singleton* Singleton::m_interface = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">worker</span><span class="params">(<span class="type">void</span>* args)</span> </span>&#123;</span><br><span class="line">    Singleton* interface = Singleton::<span class="built_in">get_interface</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> m_thread[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(m_thread+i, <span class="literal">NULL</span>, worker, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">pthread_detach</span>(m_thread[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我设置了五个线程，在回调函数里创建单例，由于对于线程竞争资源冲突现象不明显，加上了个<code>sleep(1)</code>，运行结果如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">root@iZuf6ccxsb4mprtz1c1mx2Z:~/<span class="title">Linux</span>/<span class="title">DesignPattern</span>/<span class="title">Singleton</span># ./<span class="title">Singleton_lazy_bad</span> </span></span><br><span class="line"><span class="function"><span class="title">constructor</span></span></span><br><span class="line"><span class="function"><span class="title">constructor</span></span></span><br><span class="line"><span class="function"><span class="title">constructor</span></span></span><br><span class="line"><span class="function"><span class="title">constructor</span></span></span><br><span class="line"><span class="function"><span class="title">constructor</span></span></span><br></pre></td></tr></table></figure>
<p>问题很明显，五个线程分别创建了一个单例，这是完全错误的，而且只有构造没有析构。造成了内存泄漏。</p>
<h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><p>对于线程安全问题，采用互斥锁来确保线程安全，<strong>单例模式中使用双检锁（DCL）</strong>；</p>
<blockquote>
<p><em>为什么用DCL的一些个人理解</em><br>首先使用锁的目的就是保证<code>if(m_interface == null) m_interface = new Singleton();</code>这两个语句原子化（类似），但是在创建一个单例之后<code>m_interface != nullptr</code>，就无需每次都加锁，提高性能。</p>
</blockquote>
<p>对于内存泄漏问题，使用智能指针解决。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">比较完美的懒汉式单例模式</span></span><br><span class="line"><span class="comment">使用锁解决了线程安全问题</span></span><br><span class="line"><span class="comment">使用智能指针解决内存泄漏问题</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> m_mutex;</span><br><span class="line"><span class="type">int</span> res = <span class="built_in">pthread_mutex_init</span>(&amp;m_mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>= (<span class="type">const</span> Singleton&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">// static Singleton* m_interface;</span></span><br><span class="line">    <span class="type">static</span> shared_ptr&lt;Singleton&gt; m_interface;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Singleton</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;deconstructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> shared_ptr&lt;Singleton&gt; <span class="title">get_interface</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用双检锁DCL</span></span><br><span class="line">        <span class="keyword">if</span>(m_interface == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;m_mutex);</span><br><span class="line">            <span class="keyword">if</span>(m_interface == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                m_interface = <span class="built_in">shared_ptr</span>&lt;Singleton&gt;(<span class="keyword">new</span> Singleton);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;m_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_interface;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;Singleton&gt; <span class="title">Singleton::m_interface</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">worker</span><span class="params">(<span class="type">void</span>* args)</span> </span>&#123;</span><br><span class="line">    shared_ptr&lt;Singleton&gt; interface = Singleton::<span class="built_in">get_interface</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> m_thread[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(m_thread+i, <span class="literal">NULL</span>, worker, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">pthread_detach</span>(m_thread[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下，只创建一个单例，而且成功析构。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">root@iZuf6ccxsb4mprtz1c1mx2Z:~/<span class="title">Linux</span>/<span class="title">DesignPattern</span>/<span class="title">Singleton</span># ./<span class="title">Singleton_lazy_good</span> </span></span><br><span class="line"><span class="function"><span class="title">constructor</span></span></span><br><span class="line"><span class="function"><span class="title">deconstructor</span></span></span><br></pre></td></tr></table></figure>

<p>最后还有一种基于c++11的<code>magic static</code>特性的懒汉实现，这里就不介绍了。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯问题</title>
    <url>/2021/08/10/%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="文章对应的题目"><a href="#文章对应的题目" class="headerlink" title="文章对应的题目"></a>文章对应的题目</h3><p>46 全排列（M）<br>51 N皇后（H）</p>
<span id="more"></span>

<hr>
<p>解决一个回溯问题，基本上就是一个决策树的遍历过程。有三点需要考虑：</p>
<ul>
<li><strong>路径</strong>：也就是已经做出的选择。</li>
<li><strong>选择列表</strong>：当前可以做的选择（for循环）</li>
<li><strong>结束条件</strong>：已经遍历到决策树底层，返回结果。<br>代码框架：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line">def <span class="built_in">backtrack</span>(路径, 选择列表):</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.<span class="built_in">add</span>(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">        做选择（一般是把当前节点加入到路径中）</span><br><span class="line">        <span class="built_in">backtrack</span>(路径, 选择列表)</span><br><span class="line">        撤销选择（一般是从路径中剔除当前节点，直接pop）</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="46-全排列（M）"><a href="#46-全排列（M）" class="headerlink" title="46 全排列（M）"></a>46 全排列（M）</h3><p><img src="https://upload-images.jianshu.io/upload_images/27610647-9062ea46e717d84d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ul>
<li><strong>首先是第一点</strong><br>路径：在本题中，需要遍历决策树，所以路径就是节点的值、</li>
<li><strong>第二点</strong><br>选择列表：选择列表是从所有数字中剔除路径中已经存在的节点之后，剩下的所有的选项。<br>如何判断路径中已经添加过当前节点了呢？可以使用一个布尔数组<code>used</code>。</li>
<li><strong>第三点</strong><br>结束条件：<code>path.size() == nums.size()</code>路径长度和给定的数字数量相等时，即遍历到了决策树的最底层。</li>
<li><strong>第四点</strong><br>做选择和撤销选择：这个理解较简单，在往下遍历时（做选择），在路径中加入当前节点即可，但由于我们还有个<code>used</code>数组，所以还要将判断<code>used[i]</code>，并将其置为<code>true</code>.<br>撤销选择时，即回溯，需要撤销选择，将<code>path</code>中的节点<code>pop</code>出，并将<code>used[i]</code>其置为<code>false</code>。<br>代码如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt; used)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i] == <span class="literal">true</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtrack</span>(nums, used);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="51-N皇后（H）"><a href="#51-N皇后（H）" class="headerlink" title="51 N皇后（H）"></a>51 N皇后（H）</h3><p><img src="https://upload-images.jianshu.io/upload_images/27610647-d9f944251d24d1af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><em>注：皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。</em><br>首先，回溯框架中的路径即对应一个棋盘，定义为<code>vector&lt;string&gt; board(n, string(n, &#39;.&#39;))</code><br>然后遍历每一行（对应一个<code>string</code>）中的每一列，将满足条件的置为<code>&#39;Q&#39;</code>，决策树如下：<br><img src="https://upload-images.jianshu.io/upload_images/27610647-7bbcbb50182567da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">，<br>然后对于做选择和撤销选择，即将棋盘<code>board</code>中的每一个点换成<code>&#39;Q&#39;</code>和<code>&#39;.&#39;</code>，对于判断在当前位置放置皇后是否有效，可以使用一个<code>valid</code>辅助函数判断是否有效（注：皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(vector&lt;string&gt;&amp; board, <span class="type">int</span> row, <span class="type">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = board.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 检查列是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][col] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查右上方是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查左上方是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">board</span><span class="params">(n, string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">        <span class="built_in">backtrack</span>(board, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;string&gt;&amp; board, <span class="type">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == board.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(board);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> col = <span class="number">0</span>; col &lt; board.<span class="built_in">size</span>(); col ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">valid</span>(board, row, col))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            board[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            <span class="built_in">backtrack</span>(board, row + <span class="number">1</span>);</span><br><span class="line">            board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(vector&lt;string&gt;&amp; board, <span class="type">int</span> row, <span class="type">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 检查列是否有皇后互相冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][col] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查右上方是否有皇后互相冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查左上方是否有皇后互相冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>小拓展：<br>如果我们获得一个N皇后的解法就返回结果，我们只需在得到第一个结果的时候<code>return true;</code>即可，如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数找到一个答案后就返回 true</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">backtrack</span><span class="params">(vector&lt;string&gt;&amp; board, <span class="type">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (row == board.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(board);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        board[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">backtrack</span>(board, row + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以思考一下解数独。</li>
</ul>
<hr>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://labuladong.gitee.io/algo/2/19/35/">图论基础 :: labuladong的算法小抄 (gitee.io)</a></p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2022/03/10/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="工厂方法和抽象工厂"><a href="#工厂方法和抽象工厂" class="headerlink" title="工厂方法和抽象工厂"></a>工厂方法和抽象工厂</h2><span id="more"></span>

<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p><strong>定义一个创建对象的接口，让子类决定创建哪一个类。</strong><br><img src="https://upload-images.jianshu.io/upload_images/27610647-074107ba6bb3cf98.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Product</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Product</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">concreteProductA</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">concreteProductA</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;create concreteProductA&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">concreteProductA</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">concreteProductB</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">concreteProductB</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;create concreteProductB&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">concreteProductB</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Factory</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Factory</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Product* <span class="title">creatFactory</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">createProductA</span> : <span class="keyword">public</span> Factory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Product* <span class="title">creatFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> concreteProductA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">createProductB</span> : <span class="keyword">public</span> Factory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Product* <span class="title">creatFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> concreteProductB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Factory* fac1 = <span class="keyword">new</span> <span class="built_in">createProductA</span>();</span><br><span class="line">    Factory* fac2 = <span class="keyword">new</span> <span class="built_in">createProductB</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;**********&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Product* proA = fac1-&gt;<span class="built_in">creatFactory</span>();</span><br><span class="line">    Product* proB = fac2-&gt;<span class="built_in">creatFactory</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工厂模式实现比较简单，但是工厂模式对于对象的创建仅仅局限于一个类（即Product是一个类），若要为不同的类实现对象创建的接口，需要使用<strong>抽象工厂模式</strong></p>
<hr>
<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>结构图如下：<br><img src="https://upload-images.jianshu.io/upload_images/27610647-7616d064968cd7fc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>抽象工厂可以创建多个抽象产品类，比如说一个游戏种野怪有三种难度，共十个野怪，那么对于玩家开始游戏，就需要实例化三十个类创建野怪，这时候可以选择抽象工厂方式，将难度分为三种，解决一组相关或依赖的对象。<br>代码结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象产品A和B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ProductA</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ProductB</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">concreteProductA1</span> : <span class="keyword">public</span> ProductA&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">concreteProductA1</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;create concreteProductA1&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">concreteProductA2</span> : <span class="keyword">public</span> ProductA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">concreteProductA2</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;create concreteProductA2&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">concreteProductB1</span> : <span class="keyword">public</span> ProductB &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">concreteProductB1</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;create concreteProductB1&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">concreteProductB2</span> : <span class="keyword">public</span> ProductB &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">concreteProductB2</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;create concreteProductB2&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Factory</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Factory</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ProductA* <span class="title">creatFactoryA</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ProductB* <span class="title">creatFactoryB</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化工厂，生成类型1的产品 A1和B1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">createProduct1</span> : <span class="keyword">public</span> Factory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ProductA* <span class="title">creatFactoryA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">concreteProductA1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ProductB* <span class="title">creatFactoryB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">concreteProductB1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化工厂，生成类型2的产品 A2和B2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">createProduct2</span> : <span class="keyword">public</span> Factory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ProductA* <span class="title">creatFactoryA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">concreteProductA2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ProductB* <span class="title">creatFactoryB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">concreteProductB2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Factory* fac1 = <span class="keyword">new</span> <span class="built_in">createProduct1</span>();</span><br><span class="line">    Factory* fac2 = <span class="keyword">new</span> <span class="built_in">createProduct2</span>();</span><br><span class="line">    ProductA* A1 = fac1 -&gt; <span class="built_in">creatFactoryA</span>();</span><br><span class="line">    ProductB* B1 = fac1 -&gt; <span class="built_in">creatFactoryB</span>();</span><br><span class="line">    ProductA* A2 = fac2 -&gt; <span class="built_in">creatFactoryA</span>();</span><br><span class="line">    ProductB* B2 = fac2 -&gt; <span class="built_in">creatFactoryB</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以把A、B想象成野怪，1、2想象成难度，如果玩家选择难度2，直接使用一个工厂<code>createProduct2</code>即可。</p>
<hr>
<p><strong>注意：一定要区分工厂方法和抽象工厂！！！</strong></p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>常见背包归纳</title>
    <url>/2021/11/28/%E5%B8%B8%E8%A7%81%E8%83%8C%E5%8C%85%E5%BD%92%E7%BA%B3/</url>
    <content><![CDATA[<p>基本的0-1背包、完全背包问题。</p>
<span id="more"></span>

<h1 id="一、首先对背包问题进行分类"><a href="#一、首先对背包问题进行分类" class="headerlink" title="一、首先对背包问题进行分类"></a>一、首先对背包问题进行分类</h1><ul>
<li><p>1、组合问题<br><a href="https://leetcode-cn.com/problems/combination-sum-iv/description/">377. 组合总和 Ⅳ</a><br><a href="https://leetcode-cn.com/problems/target-sum/description/">494. 目标和</a><br><a href="https://leetcode-cn.com/problems/coin-change-2/description/">518. 零钱兑换 II</a><br><strong>组合问题公式</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[i] = dp[i] + dp[i-num];</span><br></pre></td></tr></table></figure>
</li>
<li><p>2、True&#x2F;False问题<br><a href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a><br><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/description/">416. 分割等和子集</a></p>
<p><strong>True&#x2F;False问题公式</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[i] = dp[i] <span class="keyword">or</span> dp[i-num]</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">dp[i] = dp[i] | dp[i-num]</span><br></pre></td></tr></table></figure>
</li>
<li><p>3、 最大&#x2F;最小问题<br><a href="https://leetcode-cn.com/problems/ones-and-zeroes/description/">474. 一和零</a><br><a href="https://leetcode-cn.com/problems/coin-change/description/">322. 零钱兑换</a></p>
<p><strong>最大&#x2F;最小问题公式</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[i] = <span class="built_in">min</span>(dp[i], dp[i-num] + <span class="number">1</span>)</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">dp[i] = <span class="built_in">max</span>(dp[i], dp[i-num] + <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="二、背包问题技巧"><a href="#二、背包问题技巧" class="headerlink" title="二、背包问题技巧"></a>二、背包问题技巧</h1><p><strong>背包问题具备的特征</strong>：给定一个target，target可以是数字也可以是字符串，再给定一个数组nums，nums中装的可能是数字，也可能是字符串，问：能否使用nums中的元素做各种排列组合得到target。</p>
<ul>
<li>1、0-1背包<br><strong>即数组中的元素不可重复使用，nums放在外循环，target在内循环，且内循环倒序。</strong>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = target; i &gt;= nums; i--) &#123;</span><br><span class="line">        ***</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>2、完全背包<br><strong>即数组中的元素可重复使用，nums放在外循环，target在内循环。且内循环正序。</strong>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = num; i &lt;= target; i++) &#123;</span><br><span class="line">        ***</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>3、组合问题需要考虑顺序<br><strong>如果组合问题需考虑元素之间的顺序，需将target放在外循环，将nums放在内循环。</strong>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">        ***</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p>参考链接：<a href="https://leetcode-cn.com/problems/combination-sum-iv/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-wen-/">希望用一种规律搞定背包问题 - 组合总和 Ⅳ - 力扣（LeetCode） (leetcode-cn.com)</a></p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>手撕-KMP、堆排序、快排</title>
    <url>/2022/03/26/%E6%89%8B%E6%92%95-KMP%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F%E3%80%81%E5%BF%AB%E6%8E%92/</url>
    <content><![CDATA[<blockquote>
<p>经典算法手撕</p>
</blockquote>
<span id="more"></span>

<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>kmp算法的核心就是求<code>next</code>数组，即最长公共前后缀个数数组。<br>比如对于文本串<code>string s = &quot;aabaabaaf&quot;</code>，模式串<code>string t = &quot;aabaaf&quot;</code>，若要暴力检测的话，遍历到<code>s[5] != t[5]</code>，需要重新回到<code>s[1]</code>和<code>t[0]</code>重新遍历，但是若有一个数组记录最长公共前后缀的话，可以倒退到<code>s[next[5-1]+1]</code>即继续匹配<code>s[5]</code>和<code>t[2]</code>；如下图。<a href="https://www.programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html">图源：卡哥</a><br><img src="https://upload-images.jianshu.io/upload_images/27610647-445a75f6e75deb5a.gif?imageMogr2/auto-orient/strip"></p>
<p>求next数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">m_next</span><span class="params">(string&amp; str, vector&lt;<span class="type">int</span>&gt;&amp; next)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>] = j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; str[i] != str[j+<span class="number">1</span>]) &#123;</span><br><span class="line">            j = next[j];  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == str[j+<span class="number">1</span>]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求出<code>next</code>数组之后就可以进行模式匹配了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//return value : start index of s.str(T)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kmp</span><span class="params">(string &amp; str, string&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(t.size())</span></span>;</span><br><span class="line">    <span class="built_in">m_next</span>(t, next);</span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s[i] != t[j+<span class="number">1</span>]) &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == t[j+<span class="number">1</span>]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == t.<span class="built_in">size</span>()<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - t.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆分为大顶堆和小顶堆，如图所示，即根节点是最大或者最小值。<br><img src="https://upload-images.jianshu.io/upload_images/27610647-e3c284bf915c85ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>对于数组<code>vector&lt;int&gt; nums = &#123;7, 3, 9, 4, 6, 1, 5, 2, 8&#125;;</code>，若要降序输出，首先需要将该数组构造成一个小顶堆，结果为<code>9 8 7 4 6 1 5 2 3 </code>，然后交换<code>nums[0]</code>和<code>nums[nums.size()-1]</code>，继续构造小顶堆，如此循环。<br>注意：初始化构造小顶堆时，需要从第一个非叶子结点向上构造，即：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一次构造小顶堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = (nums.<span class="built_in">size</span>()/<span class="number">2</span>)<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">heapify</span>(nums, i, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造小顶堆之后继续排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//交换根节点和未排序的最后一个元素</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[i]);</span><br><span class="line">        <span class="built_in">heapify</span>(nums, <span class="number">0</span>, i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>heapify</code>的实现🌟🌟🌟🌟🌟</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> father = start;</span><br><span class="line">	<span class="type">int</span> son = <span class="number">2</span>*father + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(son &lt;= index) &#123;</span><br><span class="line">		<span class="keyword">if</span>(son &lt;= index - <span class="number">1</span> &amp;&amp; nums[son] &gt; nums[son + <span class="number">1</span>])</span><br><span class="line">			son++;</span><br><span class="line">		<span class="keyword">if</span>(nums[son] &lt; nums[father])</span><br><span class="line">			<span class="built_in">swap</span>(nums[son], nums[father]);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		father = son;</span><br><span class="line">		son = <span class="number">2</span>*father + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>C++中实现了<code>template &lt;class T, class Container = vector&lt;T&gt;,   class Compare = less&lt;typename Container::value_type&gt; &gt; class priority_queue;</code>这个STL，需要使用头文件<code>#include &lt;queue&gt;</code></p>
<p>具体用法为<code>class T</code>是保存的参数类型，<code>class Container = vector&lt;T&gt;</code>是堆中储存元素的容器，默认是<code>vector&lt;T&gt;</code>，<code>class Compare = less&lt;typename Container::value_type&gt;</code>是堆的比较函数，默认是<code>less&lt;T&gt;</code>即小顶堆，也可以使用<code>greater&lt;int&gt;</code>构造大顶堆。</p>
<p><strong>注意，优先队列队首元素为<code>que.top()</code>不是<code>que.front()</code></strong></p>
<ul>
<li><p>具体用法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; que;</span><br><span class="line">	que.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">	que.<span class="built_in">push</span>(<span class="number">8</span>);</span><br><span class="line">	que.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">	que.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line">	que.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; que.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造的是大顶堆，然后堆排序，<strong>构造出的元素为队列头部为最小值。</strong><br>输出为</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">wang@Wangs-MacBook-Pro test_cpp % ./priority_queue </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">8</span> <span class="number">9</span> %              </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>自定义比较类</strong><br>以<code>pair&lt;int, int&gt;</code>举例子，将队列中按照<code>pair.first</code>降序排列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义比较类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, cmp&gt; que;</span><br><span class="line">	que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">	que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">8</span>,<span class="number">0</span>));</span><br><span class="line">	que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">7</span>,<span class="number">0</span>));</span><br><span class="line">	que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">	que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>,<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; que.<span class="built_in">top</span>().first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">wang@Wangs-MacBook-Pro test_cpp % ./priority_queue</span><br><span class="line"><span class="number">8</span> <span class="number">7</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> %   </span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> pivotPosition = <span class="built_in">partition</span>(nums, left, right);</span><br><span class="line">	<span class="built_in">quick_sort</span>(nums, left, pivotPosition - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">quick_sort</span>(nums, pivotPosition + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="type">int</span> rand_num = left + (<span class="built_in">rand</span>()%(right-left));</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;rand_num: &quot;</span> &lt;&lt; rand_num &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">swap</span>(nums[left], nums[rand_num]);</span><br><span class="line">	<span class="type">int</span> pivot = nums[left];</span><br><span class="line">	<span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">		<span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] &gt;= pivot)</span><br><span class="line">			right--;</span><br><span class="line">		<span class="built_in">swap</span>(nums[left], nums[right]);</span><br><span class="line">		<span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] &lt;= pivot)</span><br><span class="line">			left++;</span><br><span class="line">		<span class="built_in">swap</span>(nums[left], nums[right]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">77</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">6</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">		cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">quick_sort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">		cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>手撕HashMap</title>
    <url>/2022/04/15/%E6%89%8B%E6%92%95HashMap/</url>
    <content><![CDATA[<hr>
<h2 id="HashMap不完整实现，大概意思是这样"><a href="#HashMap不完整实现，大概意思是这样" class="headerlink" title="HashMap不完整实现，大概意思是这样"></a>HashMap不完整实现，大概意思是这样</h2><span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @author Bi Wang</span></span><br><span class="line"><span class="comment">* @version 创建时间：2022-3-18</span></span><br><span class="line"><span class="comment">* 说明：本程序实现了一个HashMap。</span></span><br><span class="line"><span class="comment">* 功能：使用开链法解决Hash冲突，实现了查找、插入、删除功能。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HASHMAP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASHMAP_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashNode</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Key _key;</span><br><span class="line">    Value _value;</span><br><span class="line">    HashNode* next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HashNode</span>(Key key, Value Value):_key(key), _value(value), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">HashNode</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载赋值函数</span></span><br><span class="line">    HashNode&amp; <span class="keyword">operator</span>=(<span class="type">const</span> HashNode&amp; node) &#123;</span><br><span class="line">        _key = node._key;</span><br><span class="line">        _value = node._value;</span><br><span class="line">        next = node.next;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">HashFunc</span>, <span class="keyword">class</span> <span class="title class_">EqualKey</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashMap</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _size;</span><br><span class="line">    HashFunc hash;</span><br><span class="line">    EqualKey equal;</span><br><span class="line">    HashNode&lt;Key, Value&gt; ** hash_table;</span><br><span class="line">    Value valueNUll;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HashMap</span>(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> size));</span><br><span class="line">    ~<span class="built_in">HashMap</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> Key&amp; key, <span class="type">const</span> Value&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">del</span><span class="params">(<span class="type">const</span> Key&amp; key)</span></span>;</span><br><span class="line">    <span class="function">Value&amp; <span class="title">find</span><span class="params">(<span class="type">const</span> Key&amp; key)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">HashFunc</span>, <span class="keyword">class</span> <span class="title class_">EqualKey</span>&gt;</span><br><span class="line">HashMap&lt;Key, Value, HashFunc, EqualKey&gt;::<span class="built_in">HashMap</span>(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> size) : </span><br><span class="line">_size(size), <span class="built_in">hash</span>(), <span class="built_in">equal</span>() &#123;</span><br><span class="line">    hash_table = <span class="keyword">new</span> HashNode&lt;Key, Node&gt;*[_size];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; _size; i++) &#123;</span><br><span class="line">        hash_table[i] = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">HashFunc</span>, <span class="keyword">class</span> <span class="title class_">EqualKey</span>&gt;</span><br><span class="line">HashMap&lt;Key, Value, HashFunc, EqualKey&gt;::~<span class="built_in">HashMap</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; _size; i++) &#123;</span><br><span class="line">        HashNode&lt;Key, Value&gt;* cur = hash_table[i];</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            HashNode&lt;Key, Value&gt;* temp = cur;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] hash_table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">HashFunc</span>, <span class="keyword">class</span> <span class="title class_">EqualKey</span>&gt;</span><br><span class="line"><span class="type">bool</span> HashMap&lt;Key, Value, HashFunc, EqualKey&gt;::<span class="built_in">insert</span>(<span class="type">const</span> Key&amp; key, <span class="type">const</span> Value&amp; value) &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> index = <span class="built_in">hash</span>(key)%_size;</span><br><span class="line">    HashNode&lt;Key, Value&gt;* node = <span class="keyword">new</span> <span class="built_in">HashNode</span>&lt;Key, Value&gt;(key, value);</span><br><span class="line">    node-&gt;next = hash_table[index];</span><br><span class="line">    hash_table[index] = node;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">HashFunc</span>, <span class="keyword">class</span> <span class="title class_">EqualKey</span>&gt;</span><br><span class="line"><span class="type">bool</span> HashMap&lt;Key, Value, HashFunc, EqualKey&gt;::<span class="built_in">del</span>(<span class="type">const</span> Key&amp; key) &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> index = <span class="built_in">hash</span>(key)%_size;</span><br><span class="line">    HashNode&lt;Key, Value&gt;* node = hash_table[index];</span><br><span class="line">    HashNode&lt;Key, Value&gt;* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    prev -&gt; next = node;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node -&gt; _key == key) &#123;</span><br><span class="line">            prev -&gt; next = node -&gt; next;</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node -&gt; next;</span><br><span class="line">        prev = prev -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">HashFunc</span>, <span class="keyword">class</span> <span class="title class_">EqualKey</span>&gt;</span><br><span class="line">Value&amp; HashMap&lt;Key, Value, HashFunc, EqualKey&gt;::<span class="built_in">find</span>(<span class="type">const</span> Key&amp; key) &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> index = <span class="built_in">hash</span>(key)%_size;</span><br><span class="line">    HashNode&lt;Key, Value&gt;* node = hash_table[index];</span><br><span class="line">    <span class="keyword">if</span>(!node)   <span class="keyword">return</span> valueNUll;</span><br><span class="line">    <span class="keyword">while</span>(node) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node -&gt; _key == key)</span><br><span class="line">            <span class="keyword">return</span> node -&gt; _value;</span><br><span class="line">        node = node -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希函数</span></span><br><span class="line"><span class="comment">// class HashFunc</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     int operator()(const unsigned int &amp; key )</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         int hash = 0;</span></span><br><span class="line"><span class="comment">//         for(int i = 0; i &lt; key.length(); ++i)</span></span><br><span class="line"><span class="comment">//         &#123;</span></span><br><span class="line"><span class="comment">//             hash = hash &lt;&lt; 7 ^ key[i];</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return (hash &amp; 0x7FFFFFFF);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//比较函数，上面实现的哈希表默认是数值类型，不需要比较函数</span></span><br><span class="line"><span class="comment">// class EqualKey</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     bool operator()(const string &amp; A, const string &amp; B)</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         if (A.compare(B) == 0)</span></span><br><span class="line"><span class="comment">//             return true;</span></span><br><span class="line"><span class="comment">//         else</span></span><br><span class="line"><span class="comment">//             return false;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>手撕线程池</title>
    <url>/2022/01/22/%E6%89%8B%E6%92%95%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="线程池Threadpool简单实现"><a href="#线程池Threadpool简单实现" class="headerlink" title="线程池Threadpool简单实现"></a>线程池Threadpool简单实现</h2><span id="more"></span>

<p>作为web服务器实现高并发的基本组件之一，单独用I&#x2F;O多路复用很可能会导致后续请求阻塞，但是不断创建线程和销毁线程会增加性能开销，于是采用线程池从工作队列抢占任务。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadpool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">threadpool</span>(<span class="type">int</span> thread_num = <span class="number">5</span>, <span class="type">int</span> max_request = <span class="number">10000</span>);</span><br><span class="line">	~<span class="built_in">threadpool</span>();</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">add</span><span class="params">(T* request)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">worker</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">concreateWork</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_thread_num;</span><br><span class="line">	<span class="type">int</span> m_max_requests;</span><br><span class="line">	<span class="type">pthread_t</span>* m_thread_arr;</span><br><span class="line">	queue&lt;T&gt; m_workqueue;</span><br><span class="line">	<span class="type">bool</span> m_stop;</span><br><span class="line"></span><br><span class="line">	locker m_locker;</span><br><span class="line">	sem m_stat;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">threadpool&lt;T&gt;::<span class="built_in">threadpool</span>(<span class="type">int</span> thread_num = <span class="number">5</span>, <span class="type">int</span> max_request = <span class="number">10000</span>) </span><br><span class="line">: <span class="built_in">m_thread_num</span>(thread_num), <span class="built_in">m_max_requests</span>(max_request), <span class="built_in">m_stop</span>(<span class="literal">false</span>), <span class="built_in">m_thread_arr</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">	m_thread_arr = <span class="keyword">new</span> <span class="type">pthread_t</span>[m_thread_num];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_thread_num; i++) &#123;</span><br><span class="line">		<span class="comment">//work必须为静态成员函数</span></span><br><span class="line">		<span class="built_in">pthread_create</span>(m_thread_arr + i, <span class="literal">NULL</span>, worker, <span class="keyword">this</span>)；</span><br><span class="line">		<span class="built_in">pthread_detach</span>(m_thread_arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">threadpool&lt;T&gt;::~<span class="built_in">threadpool</span>() &#123;</span><br><span class="line">	<span class="keyword">delete</span>[] m_thread_arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> threadpool&lt;T&gt;::<span class="built_in">add</span>(T* request) &#123;</span><br><span class="line">	m_locker.<span class="built_in">lock</span>();</span><br><span class="line">	<span class="keyword">if</span>(m_workqueue.<span class="built_in">size</span>() &gt; m_max_requests) &#123;</span><br><span class="line">		m_locker.<span class="built_in">unlock</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	m_workqueue.<span class="built_in">push_back</span>(request);</span><br><span class="line">	m_workqueue.<span class="built_in">unlock</span>();</span><br><span class="line">	m_stat.<span class="built_in">post</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span>* threadpool&lt;T&gt;::<span class="built_in">worker</span>(<span class="type">void</span>* arg) &#123;</span><br><span class="line">	threadpool* work = (threadpool*) arg;</span><br><span class="line">	work -&gt; <span class="built_in">concreateWork</span>();</span><br><span class="line">	<span class="keyword">return</span> work;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> threadpool&lt;T&gt;::<span class="built_in">run</span>() &#123;</span><br><span class="line">	m_stat.<span class="built_in">wait</span>();</span><br><span class="line">	m_locker.<span class="built_in">lock</span>();</span><br><span class="line">	T* cur_request = m_workqueue.<span class="built_in">front</span>();</span><br><span class="line">	m_workqueue.<span class="built_in">pop_front</span>();</span><br><span class="line">	m_locker.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">	cur_request-&gt;<span class="built_in">process</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//封装互斥锁</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">locker</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">pthread_mutex_t</span> m_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">locker</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">exception</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">locker</span>() &#123;</span><br><span class="line">		<span class="built_in">pthread_mutex_destory</span>(&amp;m_mutex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">pthread_mutex_lock</span>(&amp;m_mutex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">pthread_mutex_unlock</span>(&amp;m_mutex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//封装信号量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sem</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">sem_t</span> m_sem;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">sem</span>() &#123;</span><br><span class="line">		<span class="built_in">sem_init</span>(&amp;m_sem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sem</span>(<span class="type">int</span> num) &#123;</span><br><span class="line">		<span class="built_in">sem_init</span>(&amp;m_sem, <span class="number">0</span>, num);</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">sem</span>() &#123;</span><br><span class="line">		<span class="built_in">sem_destory</span>(&amp;m_sem);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">post</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">sem_post</span>(&amp;m_sem);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">sem_eait</span>(&amp;m_sem);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>图论基础</title>
    <url>/2021/09/16/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="文章对应的题目"><a href="#文章对应的题目" class="headerlink" title="文章对应的题目"></a>文章对应的题目</h3><p>797 所有可能的路径（M）</p>
<span id="more"></span>

<hr>
<p>图基本的实现方式分为<strong>邻接表</strong>和<strong>邻接矩阵</strong></p>
<ul>
<li>邻接表：把每一个节点<code>x</code>的邻居都存到一个列表里，然后把<code>x</code>和这个列表关联起来，就可以通过一个节点<code>x</code>找到其所有相邻节点。</li>
<li>邻接矩阵：是一个<code>bool</code>数组，例如<code>matrix[n][n]</code>，例如节点<code>x</code>和<code>y</code>是相连的，则<code>matrix[x][y]</code>就为<code>true</code>，若需要找x的邻居，遍历一遍<code>matrix[x]</code>即可。</li>
</ul>
<p>对于<strong>图的遍历</strong>，和多叉树类似</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(GraphNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> child : root -&gt; child) &#123;</span><br><span class="line">        <span class="built_in">traverse</span>(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是对于有环图，会陷入死循环，这时候可以添加一个<code>visited</code>数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//记录被遍历过的节点</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(graph.size())</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(GraphNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || visited[root])  <span class="keyword">return</span>;</span><br><span class="line">    visited[root] == <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> child : root -&gt; child) &#123;</span><br><span class="line">        <span class="built_in">traverse</span>(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="797-所有可能的路径"><a href="#797-所有可能的路径" class="headerlink" title="797 所有可能的路径"></a>797 所有可能的路径</h3><p>题目如下：<br><img src="https://upload-images.jianshu.io/upload_images/27610647-6de8816f86e87ace.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>解法很简单，以<code>0</code>为起点遍历图，同时记录遍历过的路径，当遍历到终点时将路径记录下来即可。而且由于是无向图，所以不需要<code>visited</code>数组。<br>代码如下（图的遍历）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">allPathsSourceTarget</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph) &#123;</span><br><span class="line">        <span class="built_in">traverse</span>(graph, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="type">int</span> size = graph.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(s == size - <span class="number">1</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : graph[s]) &#123;</span><br><span class="line">            <span class="built_in">traverse</span>(graph, i);</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://labuladong.gitee.io/algo/2/19/35/">图论基础 :: labuladong的算法小抄 (gitee.io)</a></p>
<p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          </p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>模版方法模式</title>
    <url>/2022/03/15/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<hr>
<h4 id="模版方法（Template-Method）模式"><a href="#模版方法（Template-Method）模式" class="headerlink" title="模版方法（Template Method）模式"></a>模版方法（Template Method）模式</h4><span id="more"></span>

<p>在面向对象系统的设计中，对于某一个业务逻辑在不同的对象下实现细节不一样，但是逻辑框架相同，可以使用模版方法模式。</p>
<p>普通实现中，某一业务逻辑需要按照顺序执行<code>fun1</code>～<code>fun4</code>，其中<code>fun2</code>和<code>fun3</code>在对象A和B中实现不相同，代码逻辑如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">base</span>()&#123;&#125;;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">base</span>()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="title">fun2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="title">fun3</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun4</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">  ~<span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实现细节</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实现细节</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//业务逻辑</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">fun1</span>();</span><br><span class="line">    <span class="built_in">fun2</span>();</span><br><span class="line">    <span class="built_in">fun3</span>();</span><br><span class="line">    <span class="built_in">fun4</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>()&#123;&#125;;</span><br><span class="line">  ~<span class="built_in">B</span>()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不同的实现细节</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不同的实现细节</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//业务逻辑</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">fun1</span>();</span><br><span class="line">    <span class="built_in">fun2</span>();</span><br><span class="line">    <span class="built_in">fun3</span>();</span><br><span class="line">    <span class="built_in">fun4</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种实现方式破坏了<strong>依赖倒置原则（DIP）</strong>，即程序要依赖于抽象接口，而不是具体实现，所以高层（基类）应该提供接口用于不同的低层（子类）实现，控制权交给父类。</p>
<p>使用模版方法模式代码框架如下，有基类<code>Base</code>，负责业务逻辑框架的函数<code>void run()</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base</span>()&#123;&#125;;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Base</span>()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun3</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun4</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="comment">//业务逻辑</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">fun1</span>();</span><br><span class="line">    <span class="built_in">fun2</span>();</span><br><span class="line">    <span class="built_in">fun3</span>();</span><br><span class="line">    <span class="built_in">fun4</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">  ~<span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实现细节</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实现细节</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>()&#123;&#125;;</span><br><span class="line">  ~<span class="built_in">B</span>()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不同的实现细节</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不同的实现细节</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">//实现1</span></span><br><span class="line">  Base* obj1 = <span class="keyword">new</span> A;</span><br><span class="line">  obj1 -&gt; <span class="built_in">run</span>();</span><br><span class="line">  <span class="comment">//实现2</span></span><br><span class="line">  Base* obj2 = <span class="keyword">new</span> B;</span><br><span class="line">  obj2 -&gt; <span class="built_in">run</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里对于不同的业务实现A和B，高层都提供了两个接口（虚函数），逻辑交给了高层，利用了多态性和晚绑定。</p>
<hr>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存淘汰策略-LRU、LFU</title>
    <url>/2022/04/06/%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5-LRU%E3%80%81LFU/</url>
    <content><![CDATA[<p>LRU和LFU简单实现</p>
<span id="more"></span>

<h4 id="1-LRU（最近最少使用缓存）"><a href="#1-LRU（最近最少使用缓存）" class="headerlink" title="1. LRU（最近最少使用缓存）"></a>1. LRU（最近最少使用缓存）</h4><blockquote>
<p>力扣146题</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> key, val;</span><br><span class="line">    Node* prev;</span><br><span class="line">    Node* next;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> x, <span class="type">int</span> y) : <span class="built_in">key</span>(x), <span class="built_in">val</span>(y), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node* head = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    Node* tail = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DoubleList</span>() &#123;</span><br><span class="line">        head -&gt; next = tail;</span><br><span class="line">        tail -&gt; prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(Node* l_node)</span> </span>&#123;</span><br><span class="line">        l_node -&gt; next = tail;</span><br><span class="line">        l_node -&gt; prev = tail -&gt; prev;</span><br><span class="line">        tail -&gt; prev -&gt; next = l_node;</span><br><span class="line">        tail -&gt; prev = l_node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Node* l_node)</span> </span>&#123;</span><br><span class="line">        l_node -&gt; prev -&gt; next = l_node -&gt; next;</span><br><span class="line">        l_node -&gt; next -&gt; prev = l_node -&gt; prev;</span><br><span class="line">        l_node -&gt; prev = <span class="literal">nullptr</span>;</span><br><span class="line">        l_node -&gt; next = <span class="literal">nullptr</span>;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head -&gt; next == tail)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        Node* First = head -&gt; next;</span><br><span class="line">        <span class="built_in">remove</span>(First);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> First;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">List_size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, Node*&gt; map;</span><br><span class="line">    DoubleList dlist;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) : <span class="built_in">capacity</span>(capacity)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = map.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(it == map.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        Node* temp = map[key];</span><br><span class="line">        dlist.<span class="built_in">remove</span>(temp);</span><br><span class="line">        dlist.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        <span class="keyword">return</span> temp -&gt; val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = map.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(it != map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            Node* temp = map[key];</span><br><span class="line">            temp -&gt; val = value;</span><br><span class="line">            dlist.<span class="built_in">remove</span>(temp);</span><br><span class="line">            dlist.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dlist.<span class="built_in">List_size</span>() == capacity) &#123;</span><br><span class="line">            Node* first = dlist.<span class="built_in">removeFirst</span>();</span><br><span class="line">            map.<span class="built_in">erase</span>(map.<span class="built_in">find</span>(first -&gt; key));</span><br><span class="line">        &#125;</span><br><span class="line">        Node* x = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">        map.<span class="built_in">emplace</span>(key, x);</span><br><span class="line">        dlist.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-LFU（最不经常使用缓存）"><a href="#2-LFU（最不经常使用缓存）" class="headerlink" title="2. LFU（最不经常使用缓存）"></a>2. LFU（最不经常使用缓存）</h4><blockquote>
<p>力扣460题</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; key2val;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; key2freq;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, list&lt;<span class="type">int</span>&gt;&gt; freq2keys;</span><br><span class="line">    <span class="type">int</span> minFreq = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increaseFreq</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> freq = key2freq[key];</span><br><span class="line">        key2freq[key]++;</span><br><span class="line">        freq2keys[freq].<span class="built_in">remove</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(freq2keys[freq].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            freq2keys.<span class="built_in">erase</span>(freq);</span><br><span class="line">            <span class="keyword">if</span>(freq == <span class="keyword">this</span>-&gt;minFreq)</span><br><span class="line">                <span class="keyword">this</span>-&gt;minFreq++;</span><br><span class="line">        &#125;</span><br><span class="line">        freq2keys[freq+<span class="number">1</span>].<span class="built_in">push_front</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeMinfreqKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> key = freq2keys[<span class="keyword">this</span>-&gt;minFreq].<span class="built_in">back</span>();</span><br><span class="line">        freq2keys[<span class="keyword">this</span>-&gt;minFreq].<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">if</span>(freq2keys[<span class="keyword">this</span>-&gt;minFreq].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            freq2keys.<span class="built_in">erase</span>(<span class="keyword">this</span>-&gt;minFreq);</span><br><span class="line">        &#125;</span><br><span class="line">        key2val.<span class="built_in">erase</span>(key);</span><br><span class="line">        key2freq.<span class="built_in">erase</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">LFU</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;&amp; operators, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> oper : operators) &#123;</span><br><span class="line">            <span class="keyword">if</span>(oper[<span class="number">0</span>] == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = key2val.<span class="built_in">find</span>(oper[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(it == key2val.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(it-&gt;second);</span><br><span class="line">                    <span class="built_in">increaseFreq</span>(oper[<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(oper[<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = key2val.<span class="built_in">find</span>(oper[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(it != key2val.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    key2val[oper[<span class="number">1</span>]] = oper[<span class="number">2</span>];</span><br><span class="line">                    <span class="built_in">increaseFreq</span>(oper[<span class="number">1</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(size == k) &#123;</span><br><span class="line">                        <span class="built_in">removeMinfreqKey</span>();</span><br><span class="line">                        size--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    key2val[oper[<span class="number">1</span>]] = oper[<span class="number">2</span>];</span><br><span class="line">                    key2freq[oper[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">                    freq2keys[<span class="number">1</span>].<span class="built_in">push_front</span>(oper[<span class="number">1</span>]);</span><br><span class="line">                    <span class="keyword">this</span>-&gt;minFreq = <span class="number">1</span>;</span><br><span class="line">                    size++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>读写锁实现</title>
    <url>/2022/05/08/%E8%AF%BB%E5%86%99%E9%94%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="使用互斥锁和条件变量实现读写锁"><a href="#使用互斥锁和条件变量实现读写锁" class="headerlink" title="使用互斥锁和条件变量实现读写锁"></a>使用互斥锁和条件变量实现读写锁</h3><span id="more"></span>

<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">rw_lock</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> stat;   <span class="comment">//0 : 无锁，-1 : 写锁， &gt;0 : 读锁的数量</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex;  </span><br><span class="line">    <span class="type">pthread_cond_t</span> cond;  </span><br><span class="line">    </span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">rw_lock</span>() : <span class="built_in">stat</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">pthread_cond_init</span>(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">rw_lock</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rdlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span> (stat &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        ++stat;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rwunlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        --stat;</span><br><span class="line">        <span class="keyword">if</span> (stat == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">pthread_cond_signal</span>(&amp;cond);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wrlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span> (stat &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        --stat;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wrunlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        ++stat;</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;cond);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
